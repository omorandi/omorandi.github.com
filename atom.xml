<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Titanium Ninja]]></title>
  <link href="http://titaniumninja.com/atom.xml" rel="self"/>
  <link href="http://titaniumninja.com/"/>
  <updated>2011-10-30T15:55:55+01:00</updated>
  <id>http://titaniumninja.com/</id>
  <author>
    <name><![CDATA[TiNinja]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[FastDev for iOS: how it works]]></title>
    <link href="http://titaniumninja.com/post/10559549700/fastdev-for-ios-how-it-works"/>
    <updated>2011-09-23T00:00:00+02:00</updated>
    <id>http://titaniumninja.com/post/10559549700/10559549700</id>
    <content type="html"><![CDATA[<p>Some days ago I <a href="http://titaniumninja.com/post/10360108035/titanium-hack-fastdev-for-ios">published</a> a hack that allows patching the Titanium Mobile SDK for enabling fast on-device testing of iOS applications, without needing to rebuild, sign and redeploy them.</p>



<p>With this post I&#8217;d like to share some of the inner workings of the Titanium sdk that make that hack possible. I also try to explain in more detail how the hack works, so you may want to check out its source code at <a href="https://github.com/omorandi/TiiOSFastDev"><a href="https://github.com/omorandi/TiiOSFastDev">https://github.com/omorandi/TiiOSFastDev</a></a>.</p>



<p>First, I need to say that, in contrast to what many developers believe when they first approach Titanium Mobile, the JavaScript files that compose an application are not compiled to native code. Instead they get interpreted by a JavaScript engine: a slightly modified version of <a href="http://">JavaScriptCore</a> on iOS (i.e. the engine used by WebKit), and <a href="http://www.mozilla.org/rhino/">Rhino</a> (which will be hopefully soon replaced by  <a href="http://code.google.com/p/v8/">V8</a>) on Android.</p>



<p>When deploying an application on the iOS emulator, the JS engine gets fed directly with the original files that reside in the <code>Resources</code> directory of your app project, loaded at runtime. This allows you for example to see the changes you made in one file, by just restarting the app in the emulator.</p>



<p>On the other hand, when deploying on the device, the original source files are processed and packed into a single file, just before building the app. 

This step generates the <code>build/iphone/Classes/ApplicationRouting.m</code> file, which is one of the very few that are dynamically generated by the build process. Indeed, most of the objective-c files that compose the native app are simply copied from the appropriate Ti SDK directory (e.g. <code>/Library/Application\ Support/Titanium/mobilesdk/osx/1.8.0</code>) into the <code>build/iphone</code> directory of the project by the titanium build scripts when you launch the app from Ti Studio, or from the command line.</p>



<p>Once generated, <code>ApplicationRouting.m</code> contains the definition of a dictionary object that associates the name of each JS file present in the Resources directory of your project with a binary representation of its original content, along with a single class method named <code>resolveAppAsset:</code> whose only purpose is to return the appropriate file content for a given path:</p>



<script src="https://gist.github.com/1237812.js?file=gistfile1.m"></script><p>In other words, this portion of code represents the point where the original content of each JS file is dispatched to the Titanium runtime environment, which will then feed it to the JSCore interpreter.</p>



<p>As you surely understand at this point, the FastDev hack is made possible by simply using a modified version of the <code>resolveAppAsset</code> method, which, instead of returning static data, opens a connection to an HTTP server running on the development machine for retrieving the original JS files from the Resources directory:</p>



<script src="https://gist.github.com/1237725.js?file=gistfile1.m"></script><p>Actually it&#8217;s that simple, however there are some caveats:</p>



<ol><li><p>Since the method is called synchronously, also the HTTP request must be performed in a synchrounous way:</p>



<p><code>[request startSynchronous];</code></p></li>

<li><p>For testing the application on the iOS emulator, the request to the server can be made on <code>localhost</code>, however, for on-device testing, we need to know in advance the IP address at which we the server can be reached, because the modified <code>ApplicationRouting.m</code> will be built into the native application running on the target device. This is achieved through a simple trick in the startserver.py script:</p></li>

</ol><script src="https://gist.github.com/1237809.js?file=gistfile1.py"></script><p>This code allows discovering the local IP address that routes to the Internet (specifically to gmail.com), so I make the assumption that the iPhone/iPad used for testing and the development machine reside both on the same local network and that the IP address of the Mac machine on that network is also the one that routes it to the Internet.</p>



<p>So the <code>startserver.py</code> script uses this information for patching the <code>build/iphone/Classes/ServerAddr.h</code> file containing  the <code>SERVER_ADDRESS</code> define, which is used in <code>ApplicationRouting.m</code> for creating the HTTP request. This is also why the <code>startserver.py</code> script needs to be launched before building the app.</p>



<p>That&#8217;s it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titanium Hack: FastDev for iOS]]></title>
    <link href="http://titaniumninja.com/post/10360108035/titanium-hack-fastdev-for-ios"/>
    <updated>2011-09-18T00:00:00+02:00</updated>
    <id>http://titaniumninja.com/post/10360108035/10360108035</id>
    <content type="html"><![CDATA[<p>Testing large Titanium Mobile applications on iOS devices can be cumbersome, since the build &amp; deploy process can take several minutes, even when the project is launched directly from XCode. Repeating the same process each time, for checking the effect of small modifications to the code is then quite annoying and time consuming.</p>



<p>I just posted a small project on github at <a href="https://github.com/omorandi/TiiOSFastDev"><a href="https://github.com/omorandi/TiiOSFastDev">https://github.com/omorandi/TiiOSFastDev</a></a> that aims at solving this issue.</p>



<p>It is a quite hackish solution that allows you to change on the fly the application resource files of your project and get them pulled by your app (either on device or simulator) without needing to rebuild it, sign it, and re-deploy it.</p>



<p>The solution consists in a bunch of scripts that perform these operations:</p>



<ol><li><p> patch your Titanium SDK folder (or, better, a copy of it)</p></li>

<li><p>start an HTTP server in the Resources directory of your Titanium Mobile project</p></li>

</ol><p>Once these steps are completed, you can build your app and deploy it to the device for testing. Should you find you need to fix some of your program files, just do it, manually restart the app, and proceed with testing, without needing to rebuild &amp; redeploy it.</p>



<p>This process is similar to the one involved using the fastdev feature for Android, however the mechanism is not managed by Titanium Studio, and involves a series of steps to be performed manually.</p>



<p>The Ti SDK patching script expects you to work with a 1.8.X Titanium Mobile SDK. It can be modified in order to work with 1.7.X versions, however this is not currently supported.</p>



<p>The http server is implemented as a simple node js script, so for executing it you need a working node environment in your system (you can grab it from <a href="http://nodejs.org/"><a href="http://nodejs.org/">http://nodejs.org/</a></a> ).</p>



<h1>How to use it</h1>



<p>First, check out the <a href="https://github.com/omorandi/TiiOSFastDev">TiiOSFastDev repository</a>  from github.</p>



<p>In the following steps I use the following symbols for the involved directories:</p>



<pre><code>$TI_FASTDEV_DIR (the directory containing this repository)

$TI_SDK_DIR (usually /Library/Application\ Support/Titanium)

$PRJ_DIR (The root directory of your Ti Mobile App project)

</code></pre>



<ol><li><p>Check out your Titanium Mobile directory under <code>$TI_SDK_DIR</code>. There you&#8217;ll find one or more directories of the SDKs installed in your system.</p></li>

<li><p>Create a copy of the SDK directory you want to patch and call it for example <code>1.8.0-fastdev</code> (actually you&#8217;ll want to keep the original SDK directory intact for the normal development workflow)</p></li>

<li><p>In a terminal window, go to the directory that contains the files of this repository (<code>$TI_FASTDEV_DIR</code>) and perform the following:</p>



<p><code>./patch.sh 1.8.0-fastdev</code></p></li>

<li><p>Launch your Ti Mobile application from Titanium Studio or through your preferred method. This is needed in order to re-create the <code>build/iphone</code> directory in your project, with the patched files. If this doesn&#8217;t happen, just clean the project and relaunch it</p></li>

<li><p>For your convenience, create an alias for the <code>startserver.py</code>script:</p>



<p><code>alias fdstart='$TI_FASTDEV_DIR/startserver.py'</code></p></li>

<li><p>Then <code>cd</code> in the <code>Resources</code> directory of your Titanium Mobile application project, for example:</p>



<p><code>cd $PRJ_DIR/Resources</code></p></li>

<li><p>Using the previously created alias, you can start the server with:</p>



<p><code>fdstart</code></p></li>

<li><p>That&#8217;s it, you can now restart the application from Ti Studio (if you want to use the simulator), deploy it on the device, or, better, build the app for device in XCode (by opening the XCode project you find in <code>$PRJ_DIR/build/iphone</code>, sign the product and install it on device. From now on your application JS files are pulled through the server you started in the <code>Resources</code> directory of your project.</p></li>

<li><p>Enjoy the time you have saved with this hack ;-)</p></li>

</ol><h1>Demo video</h1>



<p>I made a demo for showing how this hack can be used. Please note that when launching the project from XCode I select the Simulator target only for convenience (it&#8217;s not that easy to show the iphone screen output in a screencast):</p>



<iframe src="http://player.vimeo.com/video/29218138?title=0&amp;byline=0&amp;portrait=0" width="400" height="300" frameborder="0" webkitallowfullscreen allowfullscreen></iframe>



<p><a href="http://vimeo.com/29218138">Titanium Mobile iOS FastDev hack demo</a> from <a href="http://vimeo.com/user8368459">Olivier Morandi</a> on <a href="http://vimeo.com">Vimeo</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tracing objective-c message calls]]></title>
    <link href="http://titaniumninja.com/post/9952431938/tracing-objective-c-message-calls"/>
    <updated>2011-09-08T00:00:00+02:00</updated>
    <id>http://titaniumninja.com/post/9952431938/9952431938</id>
    <content type="html"><![CDATA[<p>Developing native modules for extending Titanium Mobile is fun, but at times it can be quite frustrating, because of the lack of adequate documentation. The module development guides available in the <a href="http://wiki.appcelerator.org/">Appcelerator documentation wiki</a> only show the tip of the iceberg, and while exposing functionality through simple proxy classes is quite straightforward, things can become quickly complicated when implementing ViewProxies, i.e. those that represent view objects to be shown onscreen.</p>



<p>Actually, I&#8217;ve been mostly successful creating self contained native views, however problems started arising when I wanted to add Titanium intrinsic ViewProxies (e.g. Ti.UI.View) to my custom native views in iOS. In particular, something I&#8217;m still struggling to understand is the <em>exact</em> life cycle of TiViewProxy and their companion TiUIView objects, especially for what concerns the management of layout properties: since Titanium view objects are rendered lazily, there is a quite convoluted (at least at my eyes) mechanism in place for rearraging the layout of whole view hierarchies, which is managed by the TiViewProxy class.</p>



<p>Since Titanium is an open source project, we can always take a look at how things are implemented. Indeed, I think that reading the code of the SDK is a good way to <em>really</em> understand how Titanium Mobile works under the hood, and I plan to share some of my findings in some future post. However, reading source code can be a highly time consuming practice. Also stepping through the code with the debugger can help in some cases, but the risk is to lose a higher level view.</p>



<p>Since I wanted a more &#8220;dynamic&#8221; look at what happens to my viewproxy objects I thought that tracing the exact sequence of message calls involved between the creation and the onscreen rendering of a simple view could help. By googling around I&#8217;ve found some useful resources on the topic <a href="http://www.dribin.org/dave/blog/archives/2006/04/22/tracing_objc/">here</a> and in the <a href="http://developer.apple.com/library/mac/technotes/tn2124/_index.html#//apple_ref/doc/uid/DTS10003391-CH1-SECOBJECTIVEC">Mac OS X Debugging Magic</a> guide from Apple. It tuns out that this is a feature that can be enabled in any objective-c development environment (i.e. either for MacOS, or iOS targets) by setting the <code>NSObjCMessageLoggingEnabled</code> environment variable to <code>YES</code> in XCode before running the project. In XCode 4 this can be easily done through the <code>"Product-&gt;Edit Scheme"</code> menu, by selecting the <code>"Arguments"</code> tab and adding a new environment variable (under the <code>"Environmnet Variables"</code> section), as shown in the following picture:</p>



<p><center><img src="http://titaniumninja.com/images/posts/lr74na0S3G1qhcaa1.png"/></center></p>



<p>Then we can run the project, and all the message calls handled by objective-c objects (and classes, for static methods) are logged into a file named <code>/tmp/msgSends-&lt;pid&gt;</code>, where pid is the process ID.</p>



<p>The result is quite overwhelming and looks like an immense sequence of lines like the followings:</p>



<pre><code>+ NSObject NSObject initialize

+ NSRecursiveLock NSObject initialize

+ NSRecursiveLock NSObject new

+ NSRecursiveLock NSObject alloc

+ NSRecursiveLock NSRecursiveLock allocWithZone:

- NSRecursiveLock NSRecursiveLock init

+ NSRecursiveLock NSObject new

+ NSRecursiveLock NSObject alloc

+ NSRecursiveLock NSRecursiveLock allocWithZone:

- NSRecursiveLock NSRecursiveLock init

+ NSLock NSObject initialize

+ NSLock NSObject new

+ NSLock NSObject alloc

+ NSLock NSLock allocWithZone:

- NSLock NSLock init

+ NSLock NSObject new

+ NSLock NSObject alloc

+ NSLock NSLock allocWithZone:

- NSLock NSLock init

+ NSLock NSObject new

[...]

</code></pre>



<p>Now, what remains to do is to filter this file, searching for instances of TiWindowProxy, TiViewProxy and TiUIView, for later inspection:</p>



<pre><code>$ grep 'TiWindowProxy\|TiViewProxy\|TiUIView' /tmp/msgSends-31489 &gt; call-seq.txt

</code></pre>



<p>and the gems begin to surface:</p>



<pre><code>+ TiViewProxy NSObject initialize

+ TiWindowProxy NSObject initialize

- TiUIWindowProxy TiViewProxy init

- TiUIWindowProxy TiWindowProxy _configure

- TiViewProxy TiProxy _configure

- TiUIWindowProxy TiViewProxy _initWithProperties:

[…]

- TiUIWindowProxy TiWindowProxy open:

- TiUIWindowProxy TiWindowProxy open:

- TiUIWindowProxy TiWindowProxy isModal:

- TiUIWindowProxy TiWindowProxy argOrWindowProperty:args:

- TiUIWindowProxy TiWindowProxy isFullscreen:

- TiUIWindowProxy TiWindowProxy argOrWindowProperty:args:

- TiUIWindowProxy TiWindowProxy openOnUIThread:

- TiUIWindowProxy TiWindowProxy isRootViewAttached

- TiUIWindowProxy TiViewProxy view

- TiUIWindowProxy TiViewProxy viewWillAttach

- TiUIWindowProxy TiWindowProxy newView

- TiUIWindowProxy TiViewProxy appFrame

+ TiUIView NSObject initialize

- TiUIWindow TiUIView touchesBegan:withEvent:

- TiUIWindow TiUIView setFrame:

- TiUIWindow TiUIView proxy

+ TiViewProxy NSObject class

- TiUIWindow TiUIView setProxy:

</code></pre>



<p>I need to say that extracting useful information from this sequence is not that easy. However my plan is to follow it as a &#8220;map&#8221; while stepping through the code with the debugger.</p>



<p>Unfortunately I have no results to show yet. Just stay tuned for a follow up post where I hope I&#8217;ll be able to layout at least a portion of the TiViewProxy object lifecycle.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using intents for sending sms messages on Android with Ti Mobile]]></title>
    <link href="http://titaniumninja.com/post/6299270537/using-intents-for-sending-sms-messages-on-android-with"/>
    <updated>2011-06-08T00:00:00+02:00</updated>
    <id>http://titaniumninja.com/post/6299270537/6299270537</id>
    <content type="html"><![CDATA[<p>Titanium mobile historically lacks of support for in-app sms sending facilities. Even the availability of the <a href="http://developer.apple.com/library/ios/#documentation/MessageUI/Reference/MFMessageComposeViewController_class/Reference/Reference.html">MFMessageComposeViewController</a> class since the release of iOS 4.X didn&#8217;t push Appcelerator guys to provide an appropriate mapping in the framework API. I personally tried to overcome the issue (at least on iOS) by creating a custom <a href="https://github.com/omorandi/TiSMSDialog">native module</a>, which had a quite good response from the community.</p>







<p>After releasing the iOS module I started investigating how I could provide a similar feature also for Android devices. It turns out that programmatically sending text messages on Android can be performed in a couple of ways:</p>







<ol><li>by using the <a href="http://developer.android.com/reference/android/telephony/SmsManager.html">android.telephony.SmsManager</a> class </li>

<li>by using the default SMS app through <a href="http://developer.android.com/reference/android/content/Intent.html">intents</a></li>

</ol><p>Talking about native code, the simplest way for doing it is the latter, and all can be done with at most <a href="http://jtribe.blogspot.com/2008/12/sending-sms-using-android-intents.html">4 lines of code</a>. Since the Titanium SDK provides a direct mapping on native Android intents from release 1.5.0, implementing the same technique in a Ti Mobile project is quite straightforward:</p>







<pre>    var intent = Ti.Android.createIntent({

        action: Ti.Android.ACTION_VIEW,

        type: 'vnd.android-dir/mms-sms'

    });

    intent.putExtra('sms_body', 'new message from me');

    intent.putExtra('address', '123456789');

    Ti.Android.currentActivity.startActivity(intent);

</pre>



<p>
</p>



<p>What this snippet of code does is simply to create a Ti.Android.Intent object with the appropriate properties and start an activity for it. As a result, the SMS sending activity registered in the system (i.e. probably that of the default SMS messaging app) gets started, pre-populated with the provided recipient (address) and message body (sms_body). That&#8217;s it.</p>







<p>This solution is very simple and powerful, with the only drawback that there&#8217;s no possibility to get notified about the result of the operation, so we won&#8217;t know if the message has been actually sent or not. If in some cases this doesn&#8217;t represent a big issue, it&#8217;s highly probable that in your application you want to be notified if some problem occurred during the operation.</p>







<p>At this point I haven&#8217;t found a reliable way for being notified about the result. Even using the startActivityForResult method of Ti.Android.currentActivity, instead of startActivity doesn&#8217;t help:</p>







<pre>Ti.Android.currentActivity.startActivityForResult(intent, function(e) {

    if (e.resultCode == Ti.Android.RESULT_OK) {

      Ti.UI.createNotification({

        message: "Message Sent!"

      }).show();

    } else if (e.resultCode == Ti.Android.RESULT_CANCELED) {

      Ti.UI.createNotification({

        message: "Message sending cancelled"

      }).show();

    }

});

</pre>



<p>
</p>



<p>because the result value returned is always Ti.Android.RESULT_CANCELED. </p>







<p><a href="https://gist.github.com/1013226">Here</a> is a complete example showing two alternative techniques for sending text messages through intents on Android with Ti Mobile.</p>







<p>At this point, for Ti Mobile applications that need to be notified about the result of the operation, the only solution would be to create an Android module that wraps the <a href="http://developer.android.com/reference/android/telephony/SmsManager.html">android.telephony.SmsManager</a> class. </p>







<p>I&#8217;m currently experimenting  around some basic code for such a module, so stay tuned ;-)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Javascript]]></title>
    <link href="http://titaniumninja.com/post/5841602276/learning-javascript-used-to-mean-you-werent-a"/>
    <updated>2011-05-25T00:00:00+02:00</updated>
    <id>http://titaniumninja.com/post/5841602276/5841602276</id>
    <content type="html"><![CDATA[<blockquote>Learning Javascript used to mean you weren&#8217;t a &#8220;serious software developer&#8221;. today, not learning it means the same thing.</blockquote>&#8212;<a href="http://twitter.com/monkchips">@monkchips</a>
]]></content>
  </entry>
  
</feed>
