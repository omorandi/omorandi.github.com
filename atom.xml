<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Titanium Ninja]]></title>
  <link href="http://titaniumninja.com/atom.xml" rel="self"/>
  <link href="http://titaniumninja.com/"/>
  <updated>2012-07-10T08:53:24+02:00</updated>
  <id>http://titaniumninja.com/</id>
  <author>
    <name><![CDATA[TiNinja]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Testing Titanium Mobile applications with Jasmine and Sinon (part I)]]></title>
    <link href="http://titaniumninja.com/testing-titanium-mobile-applications-with-jasmine-and-sinon-part-i/"/>
    <updated>2012-06-11T18:16:00+02:00</updated>
    <id>http://titaniumninja.com/testing-titanium-mobile-applications-with-jasmine-and-sinon-part-i</id>
    <content type="html"><![CDATA[<p>As the code base of an application grows, manual testing becomes very quickly a cumbersome and highly error prone activity. Moreover, when fixing bugs or refactoring portions of the app, there&#8217;s no way for telling if a fix is breaking something that was previously working. In order to mitigate such drawbacks, automatic unit testing tools come at help, allowing to describe how each single component of an application must behave, and testing in a systematic way if the imposed requirements and expectations are met.</p>

<p>During the last year, which I mainly spent developing and maintaining a quite large and complex Ti Mobile application, I tried to investigate which were the available options for gradually introducing automatic testing in my development workflow. There is plenty of tools and frameworks for Javascript testing, and although most of them are obviously targeted to the web development world, some of them have been more or less successfully made available for testing Titanium Mobile applications.</p>

<p>JS dynamic nature makes it an ideal language for automatic testing: you can easily modify objects at runtime, and provide fake implementations around the code that needs to be tested. So testing JS applications, and in particular Ti Mobile applications is super easy, right? Wrong! Or better, it can be, provided that you use the right tools and that you write your code in a way that makes it easily testable. For instance, every time we use state variables and functions hidden inside closures (e.g. even just using either CommonJS, or the omni-present <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript">module pattern</a>), we are creating code that can be hard to test. An interesting take on this problem can be found <a href="http://www.adequatelygood.com/2010/7/Writing-Testable-JavaScript">here</a>.</p>

<p>In this short series of post I&#8217;d like to talk about some tools and patterns I&#8217;ve found useful for introducing automatic testing in my coding/refactoring habits.</p>

<h2>The tools</h2>

<p>There are quite <a href="http://en.wikipedia.org/wiki/List_of_unit_testing_frameworks#JavaScript">a lot</a> JavaScript testing frameworks available, some of which are dependent on the presence of a DOM, so they&#8217;re only suitable for in-browser testing and cannot be used in Titanium. Among those that are framework-independent I&#8217;ve found <a href="http://pivotal.github.com/jasmine/">Jasmine.js</a> very interesting. Jasmine is a self-contained <a href="http://dannorth.net/introducing-bdd/">Behaviour-Driven Development</a> (BDD) framework for Javascript, where tests express the &#8220;expected behaviour&#8221; for our code. I won&#8217;t go into detail on the philosophy behind this kind of Test-Driven Development practice, but those willing to dig deeper will find the <a href="http://pragprog.com/book/achbd/the-rspec-book">&#8220;RSpec Book&#8221;</a> quite useful.</p>

<p>There exist a bunch of attempts bring BDD testing with Jasmine to Titanium:</p>

<ul>
<li><a href="https://github.com/akahigeg/jasmine-titanium">akahigeg Jasmine-Titanium (github)</a></li>
<li><a href="https://github.com/guilhermechapiewski/titanium-jasmine">guilhermechapiewski Titanium-Jasmine (github)</a></li>
<li><a href="http://www.singingseal.com/dev/titanium-and-jasmine/">Cross-platform, Testable Mobile Goodness with Titanium and Jasmine</a></li>
<li>probably others more recentsâ€¦</li>
</ul>


<p>I have tried each of these approaches and none satisfied me. In particular, the second solution, which is probably the most used among the Ti community and is based on running tests directly in the target simulator, dissatisfied me for the following reasons:</p>

<ul>
<li>Testing in the simulator is very slow, while TDD is based on quick <a href="http://en.wikipedia.org/wiki/Test-driven_development#Development_style">red/green/refactor</a> iterations, where you first write the test for your code, you make it fail, you refactor and iterate until you get a green light. Even if, like me, you don&#8217;t follow religiously this practice, you quickly lose your patience waiting for the simulator to start every time</li>
<li>I think that testing in the simulator, while surely necessary at some point (mainly while doing integration and acceptance testing), allows taking short paths that quickly lead to writing poorly testable code (more on this later)</li>
</ul>


<p>Actually what I was looking for was a solution allowing me to write and execute my tests in the quickest and simplest way possible. Enter <a href="http://en.wikipedia.org/wiki/Test-driven_development#Development_style">Jasmine-Node</a>, which is a Node.js module, providing a cli for running Jasmine tests through node.</p>

<h3>Jasmine-node: setup &amp; execution</h3>

<p>Supposing you already have Node.js and npm in place, installing jasmine-node is just a matter of typing:</p>

<pre><code>$ sudo npm install jasmine-node -g
</code></pre>

<p>Now you can start executing your tests (also called <em>specs</em>), whose JS files should reside all in the same directory tree. For example, let&#8217;s consider the following directory tree, which could be part of a Ti Mobile project:</p>

<pre><code>project/
|     
+---- Resources/
|     |
|     +---- app.js
|     |
|     +---- app-modules/
|           |
|           +---- backend.js
|           |
|           +---- ui.js
|
+---- spec/
      |
      +---- backend_spec.js
      |
      +---- ui_spec.js
</code></pre>

<p>In <code>Resources</code> we have the application code, contained in a couple of CommonJS modules. Our tests reside in the <code>spec</code> directory. Please note that each file in this directory contain the <code>spec</code> string in its name, allowing jasmine-node to recognize it as a file to be evaluated by the test runner.</p>

<p>Having in mind this directory structure, we can execute our tests (e.g. from inside the <code>project</code> dir):</p>

<pre><code>$ jasmine-node spec
.............

Finished in 0.013 seconds
13 tests, 15 assertions, 0 failures
</code></pre>

<p>the command argument is simply the path of the directory containing our tests.</p>

<h3>Let&#8217;s write some code and some tests</h3>

<p>Now, we can write our code and our tests. For example, suppose in our app we have a module with some silly utility functions:</p>

<pre><code>project/Resources/app-modules/util.js:
--------------------------

exports.computeSum = function(a, b) {
    return a + b;
};
</code></pre>

<p>we can write our Jasmine spec like this:</p>

<pre><code>project/spec/util_spec.js:
--------------------------

var util = require('../Resources/app-modules/util');
describe('util tests', function() {

    it('should compute the sum between 1 &amp; 2', function(){
        var sum = util.computeSum(1, 2);
        expect(sum).toEqual(3);
    });

});
</code></pre>

<p>let&#8217;s run the spec:</p>

<pre><code>jasmine-node spec
.

Finished in 0.007 seconds
1 test, 1 assertion, 0 failures
</code></pre>

<p>I don&#8217;t enter in further details on how to write Jasmine tests, as this will be covered in the second part of this post (still to come);</p>

<p>We need to remember that specs must be written as Node.js modules and obviously the Titanium Mobile API objects won&#8217;t be available. So <strong>how can we test our Titanium modules if they make use of the Titanium API</strong>? We need to provide our tests with <em>fake</em> implementations of it. This subject leads to the concept of <a href="http://martinfowler.com/articles/mocksArentStubs.html">mocks and stubs</a> and <a href="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a>, which I&#8217;ll cover in the next episode.</p>

<h3>Caveats</h3>

<p>In this post we&#8217;ve just touched the basics about how to setup our environment for testing with node-jasmine and Titanium, however there are some somewhat hidden issues that need to be taken into account. In particular, it turns out that the Titanium implementation of CommonJS <code>require()</code> is <a href="https://jira.appcelerator.org/browse/TIDOC-514.">buggy</a> and doesn&#8217;t correctly support relative paths. This represents a major problem when trying to integrate jasmine-node test runners in projects with even minimally complex directory trees.</p>

<p>A possible solution to the issue is to not use relative paths in <code>require()</code> in Titanium (but you are free to use them in your jasmine specs run through node). Instead of relative paths we need to use full paths with <code>Resources</code> as the root directory.</p>

<p>For example, taking into account the directory tree laid out before, let&#8217;s suppose the <code>backend.js</code> module is dependent from the <code>util.js</code> module, we&#8217;ll need to write the <code>require()</code> in this way:</p>

<pre><code>project/Resources/app-modules/backend.js:
--------------------------

require('app-modules/util');

//...
</code></pre>

<p>In our jasmine specs we&#8217;ll use relative paths as usual.</p>

<p>Now the trick is to set the NODE_PATH environment variable to point to the <code>Resources</code> directory of the Ti Project, just like:</p>

<pre><code>export NODE_PATH="${PROJECT_DIR}/Resources"
jasmine-node spec   
</code></pre>

<p>This will instruct the Node.js environment to search for modules in the <code>Resources</code> directory, allowing them to be found by the test runner.</p>

<p>These two lines can obviously be encapsulated in a shell script or makefile.</p>

<h2>What next?</h2>

<p>In the next episode of this series, we&#8217;ll see how to write our application modules in Titanium, in order to make them easily testable. We&#8217;ll also expand our use of available testing frameworks, discussing how to use <a href="http://sinonjs.org/">Sinon.js</a> for creating <a href="http://martinfowler.com/articles/mocksArentStubs.html">mocks and stubs</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titanium Mobile: Flexibility vs. Performance]]></title>
    <link href="http://titaniumninja.com/titanium-mobile-flexibility-vs-performance/"/>
    <updated>2012-05-28T01:14:00+02:00</updated>
    <id>http://titaniumninja.com/titanium-mobile-flexibility-vs-performance</id>
    <content type="html"><![CDATA[<p>Last week I had the pleasure to give a talk at the <a href="http://www.whymca.org/">WhyMCA Italian Mobile Developer Conference</a>. The title of the talk is <a href="http://www.whymca.org/intervento/titanium-mobile-flexibility-vs-performance">&#8220;Titanium Mobile: Flexibility vs. Performance&#8221;</a>. Despite being structured as a quite technical speech, at it&#8217;s heart I consider it a &#8220;philosophical&#8221; one, since its message is highly related to why I think the approach to cross platform mobile development and code portability provided by Titanium is, albeit always perfectible, the right one. In this post I&#8217;d like to expand a bit on the motivations behind this line of thinking.</p>

<p>Titanium isn&#8217;t a write-once-run-everywhere platform. As Appcelerator&#8217;s guys use to say, its aim is to be a write-once-adapt-everywhere tool, since, while using a common high level language and API, it enables the exploitment of platform specific features when needed. This philosophy is clearly visible in the API, as we have entire sub-namespaces dedicated to either iOS, or Android. This allows adapting our mobile applications to the platforms where they&#8217;re executed, thus avoiding a write once, suck everywhere effect. Moreover, the possibility to develop custom native extensions to the framework opens  up a wide range of development scenarios, ideally allowing us to create user experiences that are practically undistinguishable from those of applications developed with native SDKs.</p>

<p>My point of view on this kind of approach to cross platform portability has its roots in the work I took over during 5 years as a researcher, where I explored the boundaries of flexibility (in terms of ease of development and cross platform portability) and performance in the field of network processing architectures. If you really have nothing better to do, you can check out my <a href="http://titaniumninja.com/doc/2009-PhD-MorandiOlivier.pdf">PhD dissertation thesis</a> dating back to the beginning of 2009 for additional details.</p>

<p>While at a completely different scale, in mobile application development we face challenges that are very similar to those that passionated me during my research:</p>

<ul>
<li>heterogeneous and incompatible mobile device platforms and OSs</li>
<li>while native capabilities are quite homogeneous across platforms, UIs are not</li>
<li>each platform must be programmed with it&#8217;s own SDK, each one based on a different language (e.g. Java for Android, objective-c for iOS, and so on) - code reuse and portability is impossible</li>
<li>we have stringent constraints on the User Experience: apps with a poor UX fail to gain wide adoption</li>
</ul>


<p>In this scenario, the approach proposed by Titanium is very interesting:</p>

<ul>
<li>It&#8217;s based on a high level language that abstracts away the different programming models of the target platforms</li>
<li>It provides a very wide and flexible <strong>high level</strong> API (in contrast to other technologies, like the very recent <a href="http://www.rubymotion.com/">RubyMotion</a>, which provides just Ruby wrappers around the classes of the iOS Cocoa Touch framework)</li>
<li>It&#8217;s extensible through natively coded modules for leveraging native features of the target platform</li>
</ul>


<p>Titanium applications are native by all means anyway, since even if written in JavaScript, they directly rely on native functionality. However, as its API is very general and flexible, allowing to adapt the same macro components to very disparate uses, in some cases this may cause slow downs and not so slick user experiences. It&#8217;s quite simple to explain why this happens: when the code implementing an UI component (e.g. a TableView), must be able to adapt to every possible use, we are introducing some amount of overhead, with the result of trading off performance in favor of flexibility.</p>

<p>So, in my presentation, I tried to propose two main lines of thought based on the realistic scenario of performance problems related to the creation and scrolling of a table view. The first line of thought tries to make the point that when we face a performance problem, which in mobile development is frequently a UX problem, we need to go to the root of the issue, by understanding what is causing it. This means the following things:</p>

<ul>
<li>we need to know how the tools we&#8217;re using actually work under the hood: Titanium doesn&#8217;t use the same JS engine on both iOS and Android. In particular, JavaScriptCore and V8 are very different implementations of JS, the latter being an optimizing JIT compiler, while the former is actually a bytecode interpreter, as JIT compilations is forbidden by iOS</li>
<li>As a corollary, relying on some old school micro-optimizations, like caching the length of an array while iterating over it in a for loop, may be actually useless, since if the body of the loop is &#8220;fat&#8221; enough, I&#8217;m quite sure you&#8217;re not wasting time in that check. Moreover, if that loop is &#8220;hot&#8221; enough, V8 will automatically optimize it anyway, by hoisting the access to the array length outside of the loop (check out this video from JSConf 2012: <a href="http://blip.tv/jsconf/jsconf2012-vyacheslav-egorov-6141593">&#8220;One day of life in V8&#8221; by Vyacheslav Egorov</a>)</li>
<li>We need to <strong>measure</strong>, at first even just in a rough way, in order to find where we are loosing time</li>
</ul>


<p>This last point raises an alert on the lack of accurate profiling tools that we can productively use for measuring the actual performance of our code. My extensions to Titanium for leveraging the <a href="http://titaniumninja.com/profiling-ti-mobile-apps-is-it-possible/">JavaScriptCore profiler</a> are still work in progress, and I&#8217;ll hopefully post an update on that story soon.</p>

<p>The other line of thought I pursued, is related to what we can do for increasing the scrolling performance of our table view component. Table views are a critical component in most applications, and those presenting complex row layouts can result in choppy scrolling animations for several reasons. Complex row layouts are actually a problem also when developed natively, however, in Titanium we have much less opportunities for optimizations, as we obviously need to rely on the provided API implementation, which is crafted in a way that enhances flexibility and ease of use for the developer.</p>

<p>In my presentation I propose a short investigation on the reasons that underly a lack of scrolling performance, by using the Instruments Core Animation profiling tools provided with Xcode. Scrolling issues are usually caused by transparent, or non-opaque views, like labels, which make the rendering engine do extra work for computing how superimposed views blend together. Another major pain point (often more important than the former) is represented by views with rounded corners, which need more iterations to be rendered. In this case, a very simple solution is to use image masks: a semi transparent image to be superimposed to the view that needs rounded corners. If the view is an ImageView, the <a href="http://developer.appcelerator.com/apidoc/mobile/latest/Titanium.UI.MaskedImage-object"><code>Ti.UI.MaskedImage</code></a> component does just the right job.</p>

<p>There&#8217;s an interesting session from Apple&#8217;s WWDC 2010 where these kinds of performance issues are analyzed. The talk is titled &#8220;Performance Optimization on iPhone OS&#8221;. If you are registered as an Apple developer you can download the video from <a href="https://developer.apple.com/videos/wwdc/2010/">https://developer.apple.com/videos/wwdc/2010/</a>.</p>

<p>So we come to the center point of my reasoning. If we are not able to fulfill our performance goals by tweaking our use of the standard API, Titanium allows us to implement our performance-critical components as native modules. In other words, we can trade flexibility for gaining performance. For doing so, we must give up some amount of generality and the possibility to reuse our code in other applications by implementing an optimized component that exposes an application-specific semantic: both the API and the implementation of the module will be tailored on the peculiar application and it&#8217;s performance requirements.</p>

<p>Following the table view example, on iOS this translates into having tableview rows with a hardcoded layout, possibly with sub-views whose <code>opaque</code> property is set to true on iOS, and so on. Would we still be dissatisfied with the result, we can always rely on the concept of fast-cells, which  are tableview cells actually composed by a single view, where all information to be shown is laid out by using low level CoreGraphics drawing primitives. Check out the <a href="http://iosboilerplate.com/">iOS Boilerplate project</a> and <a href="http://developer.apple.com/library/ios/#samplecode/TableViewSuite/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007318">this coding example from Apple</a> for additional information.</p>

<p>Summarizing, what does all this mean? That Titanium Mobile is a tool allowing us to create very complex <strong>cross platform</strong> mobile applications in a fraction of the time needed to make parallel developments using native SDKs. The possibility to extend the framework with native modules opens up a wide range of development scenarios, enabling both the reuse of existing native libraries, and the optimization of performance-critical portions of the app, when needed.</p>

<p>Is it a panacea? Not really, IMHO. I use Titanium since version 0.8, and despite a visible effort in making it better release after release, even now that version 2.0 is out I think it&#8217;s still a bit immature. I still see it somewhat a platform made for hackers, rather than for developers, as without a deep knowledge of its internals it&#8217;s often impractical to overcome even trivial issues like a failed build. A quick look at most of the questions on the Q&amp;A forum will suffice to support my point of view on this.</p>

<p>That said, even taking into account the problems, I think Titanium is the right tool every time we are dealing with an application that needs to support both iOS and Android platforms, whose value resides in a rather complex business logic, instead of just in the presentation layer. In these cases, we don&#8217;t want to develop, test, debug, and maintain different implementations of the same solution across different platforms. Moreover, being based on a high level abstraction layer (JS language + very flexible API), Titanium allows very quick iterations in the solution space, which is an invaluable feature when we are trying to validate business ideas against unkown markets.</p>

<p>Finally, here you find the slides of my presentation:</p>

<div style="width:425px" id="__ss_13102557"><strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/omorandi/titanium-mobile-flexibility-vs-performance-13102557" title="Titanium Mobile: flexibility vs. performance">Titanium Mobile: flexibility vs. performance</a></strong><object id="__sse13102557" width="425" height="355"><param name="movie" value="http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=oliviermorandi-whymca12-120528055815-phpapp01&stripped_title=titanium-mobile-flexibility-vs-performance-13102557&userName=omorandi" /><param name="allowFullScreen" value="true"/><param name="allowScriptAccess" value="always"/><param name="wmode" value="transparent"/><embed name="__sse13102557" src="http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=oliviermorandi-whymca12-120528055815-phpapp01&stripped_title=titanium-mobile-flexibility-vs-performance-13102557&userName=omorandi" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="transparent" width="425" height="355"></embed></object><div style="padding:5px 0 12px">View more <a href="http://www.slideshare.net/">presentations</a> from <a href="http://www.slideshare.net/omorandi">omorandi</a>.</div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash one-liner for renaming high-res image files to @2x]]></title>
    <link href="http://titaniumninja.com/bash-one-liner-for-renaming-high-res-image-files-to-at-2x/"/>
    <updated>2012-03-21T13:54:00+01:00</updated>
    <id>http://titaniumninja.com/bash-one-liner-for-renaming-high-res-image-files-to-at-2x</id>
    <content type="html"><![CDATA[<p>This tip may be useful to iOS developers when they&#8217;re given a bunch of high-resolution files and they need to rename them with the <strong><em>@2x</em></strong> filename suffix.</p>

<p>Supposing the files are all in the same directory (containing only the files you need to rename), just do this in the terminal:</p>

<pre><code>for file in *; do mv "$file" "${file%.*}@2x.${file##*.}"; done
</code></pre>

<p>As a result, the files will all be renamed following the pattern <code>&lt;name&gt;@2x.&lt;extension&gt;</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Profiling Ti Mobile apps: is it possible?]]></title>
    <link href="http://titaniumninja.com/profiling-ti-mobile-apps-is-it-possible/"/>
    <updated>2012-03-12T12:08:00+01:00</updated>
    <id>http://titaniumninja.com/profiling-ti-mobile-apps-is-it-possible</id>
    <content type="html"><![CDATA[<p>Short answer is: &#8220;YES&#8221; (at least on iOS - for now), and this post is here to share some very early results for supporting such statement. What&#8217;s reported here is just something I started working on in the last few weeks and it&#8217;s still a quite long term work in progress.</p>

<h2>Profiling tools</h2>

<p>Profiling means measuring how much time is spent in every relevant portion of code of an application during its execution, and it represents the first step to be done when searching for spots in the code that can be optimized, in order to achieve better performance. Performing any form of optimization without profiling first is like running a race with blinded eyes.</p>

<p>So, what does it mean profiling a Titanium Mobile application written in JavaScript? What tools do we have? How can we find hotspots in our poorly behaving apps? The reality is that unlike other development enviroments, the Titanium Mobile SDK doesn&#8217;t provide any tool for accurately profiling JS apps.
When developing for iOS, we can use the Instruments profiling tool provided with Xcode, and the typical results obtained using such tool are shown in the following picture:</p>

<p><img class="center" src="http://titaniumninja.com/images/posts/XcodeProfilingTool.png"></p>

<p>in the bottom-right panel we see a list of functions and methods with the associated total time spent executing them. However, while this kind of information gives us a notion on the time spent inside the functions of the framework, the time spent in our JavaScript functions, which are those we probably want to optimize, is completely hidden behind the calls to the functions of the JavaScript interpreter.</p>

<p>On the other hand, developers coming from web development may be used to working with the JS tools provided by the major browsers (e.g. Firebug in Firefox, Chrome &amp; Safari developer tools, etc.), which give us detailed profiling information on the scripts being executed by a web page. For example, the following picture shows the results obtained with the developer tools available with Chrome:</p>

<p><img class="center" src="http://titaniumninja.com/images/posts/ChromeProfiling.png"></p>

<h2>Profiling Ti apps</h2>

<p>Since I need to profile a quite complex Titanium Mobile application for finding hotspots in the code that may need to be offloaded to some native modules, I started guessing how could I achieve my goal. As usual, digging into the Ti SDK code helps a lot, and after following the white rabbit in the hole I found the response in the code of the JavaScriptCore interpreter. We always have to remember that Titanium Mobile shares its core engines with Safari and Chrome, i.e. JavaScriptCore and V8 respectively, so any low level feature tied to JS execution available in these browsers is also available in Titanium, moreover all that code is completely available as open source. So, it turns out that most of the features needed for profiling JS code are exactly where they should be, i.e. in the interpreter.</p>

<p>For those who wonder how a profiler works, it&#8217;s easy told. The profiler is nothing more than a component that records the time when each function gets called and when it returns. Whenever the interpreter needs to execute a function, it tells the profiler: &#8220;I&#8217;m going to execute function F, which starts at line X of file at URL Y&#8221;. The same just after the execution of the function: &#8220;I executed Function F, bla bla&#8221;. This allows the profiler to have a clear vision on two very important kinds of information:</p>

<ul>
<li>How function calls are related, i.e. the <a href="http://en.wikipedia.org/wiki/Call_graph">call graph</a></li>
<li>How much time is spent during the execution of every function</li>
</ul>


<p>Obviously, the total time spent in a function will also include the time spent in nested function calls, but the profiler keeps track of these situations, in order to give accurate results.</p>

<p>So, during my journey, I managed to <a href="http://titaniumninja.com/2012-03-02-building-titanium-mobile-jscore-from-source">build the JavaScriptCore library from scratch</a> and I started tweaking the code in order to be able to start and stop the profiling from the native code of a Titanium application. I had a quite encouraging success a couple of weeks ago and tweeted about it:</p>

<blockquote class="twitter-tweet"><p>YAY! got JSCore profiler running in Ti Mobile on iOS! Still work to be done for extracting useful info, though - <a href="https://t.co/yXtItEwS" title="https://skitch.com/omorandi/8ggw7/xcode">skitch.com/omorandi/8ggw7â€¦</a></p>&mdash; Olivier Morandi (@olivier_morandi) <a href="https://twitter.com/olivier_morandi/status/175231374662443010" data-datetime="2012-03-01T14:49:50+00:00">March 1, 2012</a></blockquote>


<script src="http://titaniumninja.com//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>Actually I was happy about the integration, but no real profiling data was returned. After studying more deeply the code and a lot of debugging, today I&#8217;ve been able to produce a  more meaningful profile of a test application, which is composed of a barebone <code>app.js</code> file:</p>

<script src="https://gist.github.com/2029449.js?file=app.js"></script>


<p>and a module containing a couple of functions performing some useless math tasks. The module is suitable to be either included via <code>Ti.include()</code>, or required through CommonJS <code>require()</code>:</p>

<script src="https://gist.github.com/2029449.js?file=included.js"></script>


<p>Please note that the two test functions in <code>included.js</code> are defined in different ways. The first is defined as a <strong>named function</strong> <code>test1()</code>, while the other is defined as an <strong>anonymous function</strong>, which is assigned to the variable <code>test2</code>.</p>

<p>Now let&#8217;s have a look at what results we have in the Xcode console when I run this program with Ti 2.0.0 and my modified version of the TiJSCore library (click on the image to see it at full size with annotations):</p>

<p><a href="http://titaniumninja.com/images/posts/JSCProfiling-include-annotated.png"><img class="center" src="http://titaniumninja.com/images/posts/JSCProfiling-include.png"></a></p>

<p>What gets printed in the console log is the call graph of the program, recorded during its execution. Indentation reflects the caller->called hierarchy and the reported information includes (if available) the file containing the called function, the line where the function is defined the name of the function (more on this later) and the time statistics in terms of &#8220;Total Time&#8221; spent in the function and &#8220;Self Time&#8221;, which is given by the &#8220;Total Time&#8221; for the function minus the time spent in nested calls.</p>

<p>In the call graph, some calls are reported with <code>&lt;nofile&gt;</code> file information. These are mainly native and host functions (e.g. <code>Math.cos()</code>, <code>Math.sin()</code>, <code>Ti.include()</code>, and <code>Ti.API.info()</code>), for which no source file is given. Moreover, the calls reported to <code>(program)</code> are those happening in the global scope, while those reported as <code>(Function object)</code> are those made to native and host functions. Similarly, the calls reported as <code>(anonymous function)</code> are obviously those made to anonymous functions. So, depending on how a program is structured it may be more or less easy to interpret such profiling information. For instance, in my apps, a good 90% of the functions are anonymous.</p>

<h2>How did I make it?</h2>

<p>As I told, this is still work in progress and all I have profiled until now is some very basic test application like the one reported here. For achieving these early results I had to:</p>

<ol>
<li>Extend a bit the TiJSCore library, in order to expose a couple of functions to the Ti SDK, which are used for starting and stopping the profiler.</li>
<li>Perform some very small modifications to the interpreter in order to enable code instrumentation (i.e. the code that&#8217;s used for generating profile data)</li>
<li>Modify the iOS application template generated by the Ti SDK, in order to start the profiler when the first JS execution context is created, and stop the profiling when the application goes in background (e.g. because the user presses the home button), printing the profiling report as a result</li>
</ol>


<p>All this isn&#8217;t usable yet for profiling &#8220;any&#8221; real world application, since most of the steps required still need to be done by hand (i.e. patching the Ti SDK and so on), so I think I&#8217;ll wait until the thing is a bit more stable before publishing the code.</p>

<h2>Future steps</h2>

<p>What&#8217;s missing? A lot of things, here are some:</p>

<ul>
<li>Checking out what happens with event listeners and callbacks</li>
<li>Test with more complex applications</li>
<li>Creating install scripts in order to streamline the operation on existing applications</li>
<li>Move code for starting and stopping the profiling out of the Ti SDK and put it in a module</li>
<li>Enable the possiblity to start and stop the profiling and analyzing results from a front-end cli app</li>
</ul>


<p>That&#8217;s it. If anyone is interested in more details don&#8217;t hesitate to contact me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building Titanium Mobile JSCore from source]]></title>
    <link href="http://titaniumninja.com/building-titanium-mobile-jscore-from-source/"/>
    <updated>2012-03-02T16:20:00+01:00</updated>
    <id>http://titaniumninja.com/building-titanium-mobile-jscore-from-source</id>
    <content type="html"><![CDATA[<p>As I already mentioned <a href="http://titaniumninja.com/post/10559549700/fastdev-for-ios-how-it-works/">here</a>, the Titanium Mobile framework on iOS is based on <a href="http://trac.webkit.org/wiki/JavaScriptCore">JavaScriptCore</a> (i.e. the engine used by WebKit) for interpreting and executing your app&#8217;s JS files.</p>

<p>Since part of my everyday work consists in hacking with the Ti SDK internals and building native modules it often happens that I need to track a bug or an issue down inside the core functions of the framework, and sometimes it would be useful to just take a look at the internal state of the JavaScript engine, in order to have a more detailed vision on where the problem at hand comes from.</p>

<p>However, the JSCore library (<code>libTiCore.a</code>) shipped with the Titanium SDK, is built in <em>Release</em> mode, with debug symbols stripped out, so, while its method and function names appear in a debug stack trace, it&#8217;s nearly impossible to look at actual variable and class member values.</p>

<p>Fortunately the source code of the library, customized by Appcelerator for integrating it with Titanium, is <a href="https://github.com/appcelerator/tijscore">available on github</a>, so we can create a custom build of it (e.g. a Debug version) and use it for our purposes.</p>

<p>Historically, building the library from scratch has not been much simple, nor documented. Moreover, since the process relied on several shell scripts, it was quite easy to get lost (at least at a first glance). However, in the last few months both Stephen Tramer and Blain Hamon (who are the main contributors to that code base) made a great work in simplifying and linearizing the build process.</p>

<p>This post aims at being just a quick tutorial for anyone needing to build <code>libTiCore</code> from scratch, so let&#8217;s dig in.</p>

<h2>Building the libTiCore.a library</h2>

<p>As usual, we can pull the git repo with:</p>

<pre><code>git clone https://github.com/appcelerator/tijscore.git
</code></pre>

<p>Once downloaded, in the <code>tijscore</code> directory we&#8217;ll find a couple of scripts, namely <code>fixup.py</code> and <code>buildit.sh</code> and the <code>TiCore</code> directory, which contains the original files from the JSCore sources.</p>

<p>In order to build the library we first need to run:</p>

<pre><code>./fixup.py
</code></pre>

<p>This script will patch most of the files in the TiCore directory, by changing names of files and symbols according to the Titanium namespace <strong>Ti</strong>, which is the one expected by the Ti SDK source code.</p>

<p>Then we can go with</p>

<pre><code>./buildit.sh
</code></pre>

<p>This script will build the library and create a universal binary for the armv6, armv7 and i386 architectues. The build process is quite long (a bunch of minutes on my i7 MacBook Pro) and you&#8217;ll notice it&#8217;s completed when you hear the cooling fans of your computer stop whirling like crazy.</p>

<p>The <code>buildit.sh</code> script also accepts a <em>CONFIG</em> parameter that we can use for instructing it to build a debug version of the library:</p>

<pre><code>./buildit.sh Debug
</code></pre>

<p>Once the build process is completed you&#8217;ll find the <code>libTiCore.a</code>Â library binary in the <code>TiCore/build</code> directory. The last required step is to install it in the appropriate folder of the Ti SDK:</p>

<pre><code>cp TiCore/build/libTiCore.a $TITANIUM_DIR/mobilesdk/osx/$TITANIUM_VERSION/iphone/
</code></pre>

<p>where <code>$TITANIUM_DIR</code> and <code>$TITANIUM_VERSION</code> are the root directory of your Ti SDK and the version you are currently using, e.g. <code>/Library/Application\ Support/Titanium</code> and <code>2.0.0</code> respectively.</p>

<h2>A note on libTiCore.a versions vs Ti SDK versions</h2>

<p>The Titanium Mobile SDK and the TiCore library are not really independent, so you must pay really big attention on which version of the library versus which version of the SDK you use, otherwise you will quite surely incur in linking errors when you build your titanium applications. For instance, this short tutorial is proved to work with version 16 (git hash ad8053020d) of the library,  which is used by the version 2.0.0 of the Ti SDK.</p>

<p>For 1.8.X versions of the Ti SDK you should use version 15 of the library by checking out the git tag named <code>TiCore-15</code> in the <code>tijscore</code> repository, e.g.:</p>

<pre><code>git checkout TiCore-15
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simulating slow network links on OSX]]></title>
    <link href="http://titaniumninja.com/simulating-slow-network-links-on-os-x/"/>
    <updated>2011-10-31T21:19:00+01:00</updated>
    <id>http://titaniumninja.com/simulating-slow-network-links-on-os-x</id>
    <content type="html"><![CDATA[<p>Testing mobile apps in the target platform simulator (either iOS or Android) can often be misleading, since the provided environment is an ideal one. The result is that an app working perfectly when executed in an emulated sandbox may expose unintended behaviors and perfomance when executed in open field on a real device. Moreover, not only physical resources, like processor performance and available memory are very different: also the characteristics of the  network connection available to a development machine (i.e. wifi attached to a DSL or better link) usually outperform those of the mobile Internet links available in the wild, usually ranging from no connection at all to different kinds of 3G connections.</p>

<p>Several techniques do exist for simulating more realistic network characteristics when testing mobile apps on OS X, however most of them leverage the <em>traffic shaping</em> capabilities of the <code>ipfw</code> builtin firewall. In particular, they use the <code>ipfw pipe</code> command, which allows to define a pipe where all or part of the network traffic originating from, or directed to the host will be forced into.</p>

<p>The characteristics of the pipe can be shaped according to specific requirements in terms of bandwidth, delay and packet-loss-ratio of the link that needs to be modeled, thus enabling a high flexibility. A pipe can be configured through the following command:</p>

<pre><code>ipfw pipe &lt;num&gt; config bw &lt;bw&gt; delay &lt;d&gt; plr &lt;plr&gt;
</code></pre>

<p>where <code>num</code> is a number identifying the pipe, <code>bw</code> the desired bandwidth measured in <code>[K|M]{bit/s|Byte/s}</code>, <code>delay</code> is the propagation delay measured in milliseconds, and <code>plr</code> is the packet-loss-ratio, i.e. a number in the range [0..1].</p>

<p>The following adds a firewall rule for the pipe:</p>

<pre><code>ipfw add &lt;rule-num&gt; pipe &lt;num&gt; &lt;protocol&gt; from &lt;src&gt; to &lt;dst&gt;
</code></pre>

<p>The meaning of the command is the following:</p>

<pre><code>* add rule with number rule-num
* get all the packets containing protocol and directed from src to dst
* flow them through the pipe identified by num
</code></pre>

<p>For example, modeling a GPRS link could be done with:</p>

<pre><code>sudo ipfw pipe 1 config bw 56Kbit/s delay 200 plr 0.2
sudo ipfw add 1 pipe 1 ip from any to any
</code></pre>

<p>which forces all the ip traffic through a 56Kbps link with a 200ms delay, which loses 20 packets out of 100 in average.</p>

<p>It should be noted that while the rule is enforced, <strong>all</strong> the network traffic generated from or directed to the host machine is affected. Once the testing has been performed, the rule can be deleted with the command:</p>

<pre><code>sudo ipfw delete 1
</code></pre>

<p>Not all network links have symmetric characteristics. In those cases it&#8217;s possible to model in a different way the uplink and the downlink sections with the following rules:</p>

<pre><code>sudo ipfw pipe 1 config bw 780Kbps delay 100
sudo ipfw pipe 2 config bw 330Kbps delay 100
sudo ipfw add 1 pipe 1 in proto ip
sudo ipfw add 1 pipe 2 out proto ip
</code></pre>

<p>More details can be found in the <a href="http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man8/ipfw.8.html">ipfw man page</a> and in the original <a href="http://info.iet.unipi.it/~luigi/dummynet/">Dummynet project</a> page.</p>

<p>Using this technique from the command line, while effective, is probably not much practical. Moreover, figuring out realistic values for the required parameters can be a quite difficult task. A help in overcoming these issues comes from the developer tools available with XCode 4.2 on OS X Lion that, among others, provide a system preference pane called &#8220;Network Link Conditioner&#8221;, which allows to perform the same operations I listed before through a simple GUI, with a lot of predefined configuration templates.</p>

<p>The tool can be found here:</p>

<pre><code>/Developer/Applications/Utilities/Network\ Link\ Conditioner/Network Link Conditioner.prefPane
</code></pre>

<p>and once installed is made available in the System Preferences:</p>

<p><img class="center" src="http://titaniumninja.com/images/posts/NetConditionerSysPref.png"></p>

<p>The panel allows selecting a configuration from a list of presets, which comprise different kinds of mobile and &#8220;home&#8221; network links:</p>

<p><img class="center" src="http://titaniumninja.com/images/posts/NetConditioner.png"></p>

<p>The desired settings can be activated through the big switch present on the left of the panel and, in case the available presets are not sufficient, it&#8217;s possible to define custom configurations through the &#8220;Manage Profiles&#8221; button:</p>

<p><img class="center" src="http://titaniumninja.com/images/posts/NetConditionerManage.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FastDev for iOS: how it works]]></title>
    <link href="http://titaniumninja.com/post/10559549700/fastdev-for-ios-how-it-works"/>
    <updated>2011-09-23T00:00:00+02:00</updated>
    <id>http://titaniumninja.com/post/10559549700/10559549700</id>
    <content type="html"><![CDATA[<p>Some days ago I <a href="http://titaniumninja.com/post/10360108035/titanium-hack-fastdev-for-ios">published</a> a hack that allows patching the Titanium Mobile SDK for enabling fast on-device testing of iOS applications, without needing to rebuild, sign and redeploy them.</p>



<p>With this post I&#8217;d like to share some of the inner workings of the Titanium sdk that make that hack possible. I also try to explain in more detail how the hack works, so you may want to check out its source code at <a href="https://github.com/omorandi/TiiOSFastDev"><a href="https://github.com/omorandi/TiiOSFastDev">https://github.com/omorandi/TiiOSFastDev</a></a>.</p>



<p>First, I need to say that, in contrast to what many developers believe when they first approach Titanium Mobile, the JavaScript files that compose an application are not compiled to native code. Instead they get interpreted by a JavaScript engine: a slightly modified version of <a href="http://">JavaScriptCore</a> on iOS (i.e. the engine used by WebKit), and <a href="http://www.mozilla.org/rhino/">Rhino</a> (which will be hopefully soon replaced by  <a href="http://code.google.com/p/v8/">V8</a>) on Android.</p>



<p>When deploying an application on the iOS emulator, the JS engine gets fed directly with the original files that reside in the <code>Resources</code> directory of your app project, loaded at runtime. This allows you for example to see the changes you made in one file, by just restarting the app in the emulator.</p>



<p>On the other hand, when deploying on the device, the original source files are processed and packed into a single file, just before building the app. 

This step generates the <code>build/iphone/Classes/ApplicationRouting.m</code> file, which is one of the very few that are dynamically generated by the build process. Indeed, most of the objective-c files that compose the native app are simply copied from the appropriate Ti SDK directory (e.g. <code>/Library/Application\ Support/Titanium/mobilesdk/osx/1.8.0</code>) into the <code>build/iphone</code> directory of the project by the titanium build scripts when you launch the app from Ti Studio, or from the command line.</p>



<p>Once generated, <code>ApplicationRouting.m</code> contains the definition of a dictionary object that associates the name of each JS file present in the Resources directory of your project with a binary representation of its original content, along with a single class method named <code>resolveAppAsset:</code> whose only purpose is to return the appropriate file content for a given path:</p>



<script src="https://gist.github.com/1237812.js?file=gistfile1.m"></script><p>In other words, this portion of code represents the point where the original content of each JS file is dispatched to the Titanium runtime environment, which will then feed it to the JSCore interpreter.</p>



<p>As you surely understand at this point, the FastDev hack is made possible by simply using a modified version of the <code>resolveAppAsset</code> method, which, instead of returning static data, opens a connection to an HTTP server running on the development machine for retrieving the original JS files from the Resources directory:</p>



<script src="https://gist.github.com/1237725.js?file=gistfile1.m"></script><p>Actually it&#8217;s that simple, however there are some caveats:</p>



<ol><li><p>Since the method is called synchronously, also the HTTP request must be performed in a synchrounous way:</p>



<p><code>[request startSynchronous];</code></p></li>

<li><p>For testing the application on the iOS emulator, the request to the server can be made on <code>localhost</code>, however, for on-device testing, we need to know in advance the IP address at which we the server can be reached, because the modified <code>ApplicationRouting.m</code> will be built into the native application running on the target device. This is achieved through a simple trick in the startserver.py script:</p></li>

</ol><script src="https://gist.github.com/1237809.js?file=gistfile1.py"></script><p>This code allows discovering the local IP address that routes to the Internet (specifically to gmail.com), so I make the assumption that the iPhone/iPad used for testing and the development machine reside both on the same local network and that the IP address of the Mac machine on that network is also the one that routes it to the Internet.</p>



<p>So the <code>startserver.py</code> script uses this information for patching the <code>build/iphone/Classes/ServerAddr.h</code> file containing  the <code>SERVER_ADDRESS</code> define, which is used in <code>ApplicationRouting.m</code> for creating the HTTP request. This is also why the <code>startserver.py</code> script needs to be launched before building the app.</p>



<p>That&#8217;s it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titanium Hack: FastDev for iOS]]></title>
    <link href="http://titaniumninja.com/post/10360108035/titanium-hack-fastdev-for-ios"/>
    <updated>2011-09-18T00:00:00+02:00</updated>
    <id>http://titaniumninja.com/post/10360108035/10360108035</id>
    <content type="html"><![CDATA[<p>Testing large Titanium Mobile applications on iOS devices can be cumbersome, since the build &amp; deploy process can take several minutes, even when the project is launched directly from XCode. Repeating the same process each time, for checking the effect of small modifications to the code is then quite annoying and time consuming.</p>



<p>I just posted a small project on github at <a href="https://github.com/omorandi/TiiOSFastDev"><a href="https://github.com/omorandi/TiiOSFastDev">https://github.com/omorandi/TiiOSFastDev</a></a> that aims at solving this issue.</p>



<p>It is a quite hackish solution that allows you to change on the fly the application resource files of your project and get them pulled by your app (either on device or simulator) without needing to rebuild it, sign it, and re-deploy it.</p>



<p>The solution consists in a bunch of scripts that perform these operations:</p>



<ol><li><p>Â patch your Titanium SDK folder (or, better, a copy of it)</p></li>

<li><p>start an HTTP server in the Resources directory of your Titanium Mobile project</p></li>

</ol><p>Once these steps are completed, you can build your app and deploy it to the device for testing. Should you find you need to fix some of your program files, just do it, manually restart the app, and proceed with testing, without needing to rebuild &amp; redeploy it.</p>



<p>This process is similar to the one involved using the fastdev feature for Android, however the mechanism is not managed by Titanium Studio, and involves a series of steps to be performed manually.</p>



<p>The Ti SDK patching script expects you to work with a 1.8.X Titanium Mobile SDK. It can be modified in order to work with 1.7.X versions, however this is not currently supported.</p>



<p>The http server is implemented as a simple node js script, so for executing it you need a working node environment in your systemÂ (you can grab it from <a href="http://nodejs.org/"><a href="http://nodejs.org/">http://nodejs.org/</a></a> ).</p>



<h1>How to use it</h1>



<p>First, check out the <a href="https://github.com/omorandi/TiiOSFastDev">TiiOSFastDev repository</a>Â  from github.</p>



<p>In the following steps I use the following symbols for the involved directories:</p>



<pre><code>$TI_FASTDEV_DIR (the directory containing this repository)

$TI_SDK_DIR (usually /Library/Application\ Support/Titanium)

$PRJ_DIR (The root directory of your Ti Mobile App project)

</code></pre>



<ol><li><p>Check out your Titanium Mobile directory under <code>$TI_SDK_DIR</code>. There you&#8217;ll find one or more directories of the SDKs installed in your system.</p></li>

<li><p>Create a copy of the SDK directory you want to patch and call it for example <code>1.8.0-fastdev</code> (actually you&#8217;ll want to keep the original SDK directory intact for the normal development workflow)</p></li>

<li><p>In a terminal window, go to the directory that contains the files of this repository (<code>$TI_FASTDEV_DIR</code>) and perform the following:</p>



<p><code>./patch.sh 1.8.0-fastdev</code></p></li>

<li><p>Launch your Ti Mobile application from Titanium Studio or through your preferred method. This is needed in order to re-create the <code>build/iphone</code> directory in your project, with the patched files. If this doesn&#8217;t happen, just clean the project and relaunch it</p></li>

<li><p>For your convenience, create an alias for the <code>startserver.py</code>script:</p>



<p><code>alias fdstart='$TI_FASTDEV_DIR/startserver.py'</code></p></li>

<li><p>Then <code>cd</code> in the <code>Resources</code> directory of your Titanium Mobile application project, for example:</p>



<p><code>cd $PRJ_DIR/Resources</code></p></li>

<li><p>Using the previously created alias, you can start the server with:</p>



<p><code>fdstart</code></p></li>

<li><p>That&#8217;s it, you can now restart the application from Ti Studio (if you want to use the simulator), deploy it on the device, or, better, build the app for device in XCode (by opening the XCode project you find in <code>$PRJ_DIR/build/iphone</code>, sign the product and install it on device. From now on your application JS files are pulled through the server you started in the <code>Resources</code> directory of your project.</p></li>

<li><p>Enjoy the time you have saved with this hack ;-)</p></li>

</ol><h1>Demo video</h1>



<p>I made a demo for showing how this hack can be used. Please note that when launching the project from XCode I select the Simulator target only for convenience (it&#8217;s not that easy to show the iphone screen output in a screencast):</p>



<iframe src="http://player.vimeo.com/video/29218138?title=0&amp;byline=0&amp;portrait=0" width="400" height="300" frameborder="0" webkitallowfullscreen allowfullscreen></iframe>



<p><a href="http://vimeo.com/29218138">Titanium Mobile iOS FastDev hack demo</a> from <a href="http://vimeo.com/user8368459">Olivier Morandi</a> on <a href="http://vimeo.com">Vimeo</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tracing objective-c message calls]]></title>
    <link href="http://titaniumninja.com/post/9952431938/tracing-objective-c-message-calls"/>
    <updated>2011-09-08T00:00:00+02:00</updated>
    <id>http://titaniumninja.com/post/9952431938/9952431938</id>
    <content type="html"><![CDATA[<p>Developing native modules for extending Titanium Mobile is fun, but at times it can be quite frustrating, because of the lack of adequate documentation. The module development guides available in the <a href="http://wiki.appcelerator.org/">Appcelerator documentation wiki</a> only show the tip of the iceberg, and while exposing functionality through simple proxy classes is quite straightforward, things can become quickly complicated when implementing ViewProxies, i.e. those that represent view objects to be shown onscreen.</p>



<p>Actually, I&#8217;ve been mostly successful creating self contained native views, however problems started arising when I wanted to add Titanium intrinsic ViewProxies (e.g. Ti.UI.View) to my custom native views in iOS. In particular, something I&#8217;m still struggling to understand is the <em>exact</em> life cycle of TiViewProxy and their companion TiUIView objects, especially for what concerns the management of layout properties: since Titanium view objects are rendered lazily, there is a quite convoluted (at least at my eyes) mechanism in place for rearraging the layout of whole view hierarchies, which is managed by the TiViewProxy class.</p>



<p>Since Titanium is an open source project, we can always take a look at how things are implemented. Indeed, I think that reading the code of the SDK is a good way to <em>really</em> understand how Titanium Mobile works under the hood, and I plan to share some of my findings in some future post. However, reading source code can be a highly time consuming practice. Also stepping through the code with the debugger can help in some cases, but the risk is to lose a higher level view.</p>



<p>Since I wanted a more &#8220;dynamic&#8221; look at what happens to my viewproxy objects I thought that tracing the exact sequence of message calls involved between the creation and the onscreen rendering of a simple view could help. By googling around I&#8217;ve found some useful resources on the topic <a href="http://www.dribin.org/dave/blog/archives/2006/04/22/tracing_objc/">here</a> and in the <a href="http://developer.apple.com/library/mac/technotes/tn2124/_index.html#//apple_ref/doc/uid/DTS10003391-CH1-SECOBJECTIVEC">Mac OS X Debugging Magic</a> guide from Apple. It tuns out that this is a feature that can be enabled in any objective-c development environment (i.e. either for MacOS, or iOS targets) by setting the <code>NSObjCMessageLoggingEnabled</code> environment variable to <code>YES</code> in XCode before running the project. In XCode 4 this can be easily done through the <code>"Product-&gt;Edit Scheme"</code> menu, by selecting the <code>"Arguments"</code> tab and adding a new environment variable (under the <code>"Environmnet Variables"</code> section), as shown in the following picture:</p>



<p><center><img src="http://titaniumninja.com/images/posts/lr74na0S3G1qhcaa1.png"/></center></p>



<p>Then we can run the project, and all the message calls handled by objective-c objects (and classes, for static methods) are logged into a file named <code>/tmp/msgSends-&lt;pid&gt;</code>, where pid is the process ID.</p>



<p>The result is quite overwhelming and looks like an immense sequence of lines like the followings:</p>



<pre><code>+ NSObject NSObject initialize

+ NSRecursiveLock NSObject initialize

+ NSRecursiveLock NSObject new

+ NSRecursiveLock NSObject alloc

+ NSRecursiveLock NSRecursiveLock allocWithZone:

- NSRecursiveLock NSRecursiveLock init

+ NSRecursiveLock NSObject new

+ NSRecursiveLock NSObject alloc

+ NSRecursiveLock NSRecursiveLock allocWithZone:

- NSRecursiveLock NSRecursiveLock init

+ NSLock NSObject initialize

+ NSLock NSObject new

+ NSLock NSObject alloc

+ NSLock NSLock allocWithZone:

- NSLock NSLock init

+ NSLock NSObject new

+ NSLock NSObject alloc

+ NSLock NSLock allocWithZone:

- NSLock NSLock init

+ NSLock NSObject new

[...]

</code></pre>



<p>Now, what remains to do is to filter this file, searching for instances of TiWindowProxy, TiViewProxy and TiUIView, for later inspection:</p>



<pre><code>$ grep 'TiWindowProxy\|TiViewProxy\|TiUIView' /tmp/msgSends-31489 &gt; call-seq.txt

</code></pre>



<p>and the gems begin to surface:</p>



<pre><code>+ TiViewProxy NSObject initialize

+ TiWindowProxy NSObject initialize

- TiUIWindowProxy TiViewProxy init

- TiUIWindowProxy TiWindowProxy _configure

- TiViewProxy TiProxy _configure

- TiUIWindowProxy TiViewProxy _initWithProperties:

[â€¦]

- TiUIWindowProxy TiWindowProxy open:

- TiUIWindowProxy TiWindowProxy open:

- TiUIWindowProxy TiWindowProxy isModal:

- TiUIWindowProxy TiWindowProxy argOrWindowProperty:args:

- TiUIWindowProxy TiWindowProxy isFullscreen:

- TiUIWindowProxy TiWindowProxy argOrWindowProperty:args:

- TiUIWindowProxy TiWindowProxy openOnUIThread:

- TiUIWindowProxy TiWindowProxy isRootViewAttached

- TiUIWindowProxy TiViewProxy view

- TiUIWindowProxy TiViewProxy viewWillAttach

- TiUIWindowProxy TiWindowProxy newView

- TiUIWindowProxy TiViewProxy appFrame

+ TiUIView NSObject initialize

- TiUIWindow TiUIView touchesBegan:withEvent:

- TiUIWindow TiUIView setFrame:

- TiUIWindow TiUIView proxy

+ TiViewProxy NSObject class

- TiUIWindow TiUIView setProxy:

</code></pre>



<p>I need to say that extracting useful information from this sequence is not that easy. However my plan is to follow it as a &#8220;map&#8221; while stepping through the code with the debugger.</p>



<p>Unfortunately I have no results to show yet. Just stay tuned for a follow up post where I hope I&#8217;ll be able to layout at least a portion of the TiViewProxy object lifecycle.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using intents for sending sms messages on Android with Ti Mobile]]></title>
    <link href="http://titaniumninja.com/post/6299270537/using-intents-for-sending-sms-messages-on-android-with"/>
    <updated>2011-06-08T00:00:00+02:00</updated>
    <id>http://titaniumninja.com/post/6299270537/6299270537</id>
    <content type="html"><![CDATA[<p>Titanium mobile historically lacks of support for in-app sms sending facilities. Even the availability of theÂ <a href="http://developer.apple.com/library/ios/#documentation/MessageUI/Reference/MFMessageComposeViewController_class/Reference/Reference.html">MFMessageComposeViewController</a>Â class since the release of iOS 4.X didn&#8217;t push Appcelerator guys to provide an appropriate mapping in the framework API. I personally tried to overcome the issue (at least on iOS) by creating a custom <a href="https://github.com/omorandi/TiSMSDialog">native module</a>, which had a quite good response from the community.</p>







<p>After releasing the iOS module I started investigating how I could provide a similar feature also for Android devices. It turns out that programmatically sending text messages on Android can be performed in a couple of ways:</p>







<ol><li>by using theÂ <a href="http://developer.android.com/reference/android/telephony/SmsManager.html">android.telephony.SmsManager</a> class </li>

<li>by using the default SMS app through <a href="http://developer.android.com/reference/android/content/Intent.html">intents</a></li>

</ol><p>Talking about native code, the simplest way for doing it is the latter, and all can be done with at most <a href="http://jtribe.blogspot.com/2008/12/sending-sms-using-android-intents.html">4 lines of code</a>. Since the Titanium SDK provides a direct mapping on native Android intents from release 1.5.0, implementing the same technique in a Ti Mobile project is quite straightforward:</p>







<pre>    var intent = Ti.Android.createIntent({

        action: Ti.Android.ACTION_VIEW,

        type: 'vnd.android-dir/mms-sms'

    });

    intent.putExtra('sms_body', 'new message from me');

    intent.putExtra('address', '123456789');

    Ti.Android.currentActivity.startActivity(intent);

</pre>



<p>
</p>



<p>What this snippet of code does is simply to create a Ti.Android.Intent object with the appropriate properties and start an activity for it. As a result, the SMS sending activity registered in the system (i.e. probably that of the default SMS messaging app) gets started, pre-populated with the provided recipient (address) and message body (sms_body). That&#8217;s it.</p>







<p>This solution is very simple and powerful, with the only drawback that there&#8217;s no possibility to get notified about the result of the operation, so we won&#8217;t know if the message has been actually sent or not. If in some cases this doesn&#8217;t represent a big issue, it&#8217;s highly probable that in your application you want to be notified if some problem occurred during the operation.</p>







<p>At this point I haven&#8217;t found a reliable way for being notified about the result. Even using the startActivityForResult method of Ti.Android.currentActivity, instead of startActivity doesn&#8217;t help:</p>







<pre>Ti.Android.currentActivity.startActivityForResult(intent, function(e) {

    if (e.resultCode == Ti.Android.RESULT_OK) {

      Ti.UI.createNotification({

        message: "Message Sent!"

      }).show();

    } else if (e.resultCode == Ti.Android.RESULT_CANCELED) {

      Ti.UI.createNotification({

        message: "Message sending cancelled"

      }).show();

    }

});

</pre>



<p>
</p>



<p>because the result value returned is always Ti.Android.RESULT_CANCELED.Â </p>







<p><a href="https://gist.github.com/1013226">Here</a> is a complete example showing two alternative techniques for sending text messages through intents on Android with Ti Mobile.</p>







<p>At this point, for Ti Mobile applications that need to be notified about the result of the operation, the only solution would be to create an Android module that wraps theÂ <a href="http://developer.android.com/reference/android/telephony/SmsManager.html">android.telephony.SmsManager</a>Â class.Â </p>







<p>I&#8217;m currently experimenting Â around some basic code for such a module, so stay tuned ;-)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Javascript]]></title>
    <link href="http://titaniumninja.com/post/5841602276/learning-javascript-used-to-mean-you-werent-a"/>
    <updated>2011-05-25T00:00:00+02:00</updated>
    <id>http://titaniumninja.com/post/5841602276/5841602276</id>
    <content type="html"><![CDATA[<blockquote>Learning Javascript used to mean you weren&#8217;t a &#8220;serious software developer&#8221;. today, not learning it means the same thing.</blockquote>&#8212;<a href="http://twitter.com/monkchips">@monkchips</a>
]]></content>
  </entry>
  
</feed>
