
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Titanium Ninja</title>
  <meta name="author" content="TiNinja">

  
  <meta name="description" content="As I already mentioned here, the Titanium Mobile framework on iOS is based on JavaScriptCore (i.e. the engine used by WebKit) for interpreting and &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://titaniumninja.com">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="http://feeds.feedburner.com/TitaniumNinja" rel="alternate" title="Titanium Ninja" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href='http://fonts.googleapis.com/css?family=Alike+Angular' rel='stylesheet' type='text/css'>
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-8810685-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Titanium Ninja</a></h1>
  
    <h2>App and module development with Titanium Mobile</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="http://feeds.feedburner.com/TitaniumNinja" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:titaniumninja.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/whoami/">whoami</a></li>	
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/using-a-custom-build-of-jscore-in-titanium-ios/">Building Titanium Mobile JSCore From Source</a></h1>
    
    
      <p class="meta">
        




  

<time datetime="2012-03-02T16:20:00+01:00" pubdate>Mar 2<span>nd</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>As I already mentioned <a href="http://titaniumninja.com/post/10559549700/fastdev-for-ios-how-it-works/">here</a>, the Titanium Mobile framework on iOS is based on <a href="http://trac.webkit.org/wiki/JavaScriptCore">JavaScriptCore</a> (i.e. the engine used by WebKit) for interpreting and executing your app&#8217;s JS files.</p>

<p>Since part of my everyday work consists in hacking with the Ti SDK internals and building native modules it often happens that I need to track a bug or an issue down inside the core functions of the framework, and sometimes it would be useful to just take a look at the internal state of the JavaScript engine, in order to have a more detailed vision on where the problem at hand comes from.</p>

<p>However, the JSCore library (<code>libTiCore.a</code>) shipped with the Titanium SDK, is built in <em>Release</em> mode, with debug symbols stripped out, so, while its method and function names appear in a debug stack trace, it&#8217;s nearly impossible to look at actual variable and class member values.</p>

<p>Fortunately the source code of the library, customized by Appcelerator for integrating it with Titanium, is <a href="https://github.com/appcelerator/tijscore">available on github</a>, so we can create a custom build of it (e.g. a Debug version) and use it for our purposes.</p>

<p>Historically, building the library from scratch has not been much simple, nor documented. Moreover, since the process relied on several shell scripts, it was quite easy to get lost (at least at a first glance). However, in the last few months both Stephen Tramer and Blain Hamon (who are the main contributors to that code base) made a great work in simplifying and linearizing the build process.</p>

<p>This post aims at being just a quick tutorial for anyone needing to build <code>libTiCore</code> from scratch, so let&#8217;s dig in.</p>

<h1>Building the libTiCore.a library</h1>

<p>As usual, we can pull the git repo with:</p>

<pre><code>git clone https://github.com/appcelerator/tijscore.git
</code></pre>

<p>Once downloaded, in the <code>tijscore</code> directory we&#8217;ll find a couple of scripts, namely <code>fixup.py</code> and <code>buildit.sh</code> and the <code>TiCore</code> directory, which contains the original files from the JSCore sources.</p>

<p>In order to build the library we first need to run:</p>

<pre><code>./fixup.py
</code></pre>

<p>This script will patch most of the files in the TiCore directory, by changing names of files and symbols according to the Titanium namespace <strong>Ti</strong>, which is the one expected by the Ti SDK source code.</p>

<p>Then we can go with</p>

<pre><code>./buildit.sh
</code></pre>

<p>This script will build the library and create a universal binary for the armv6, armv7 and i386 architectues. The build process is quite long (a bunch of minutes on my i7 MacBook Pro) and you&#8217;ll notice it&#8217;s completed when you hear the cooling fans of your computer stop whirling like crazy.</p>

<p>The <code>buildit.sh</code> script also accepts a <em>VERSION</em> parameter that we can use for instructing it to build a debug version of the library:</p>

<pre><code>./buildit.sh Debug
</code></pre>

<p>Once the build process is completed you&#8217;ll find the <code>libTiCore.a</code> library binary in the <code>TiCore/build</code> directory. The last required step is to install it in the appropriate folder of the Ti SDK:</p>

<pre><code>cp TiCore/build/libTiCore.a $TITANIUM_DIR/mobilesdk/osx/$TITANIUM_VERSION/iphone/
</code></pre>

<p>where <code>$TITANIUM_DIR</code> and <code>$TITANIUM_VERSION</code> are respectively the root directory of your Ti SDK and the version you are currently using, e.g. <code>/Library/Application\ Support/Titanium</code> and 2.0.0.</p>

<h1>A note on libTiCore.a versions vs Ti SDK versions</h1>

<p>The Titanium Mobile SDK and the TiCore library are not really independent, so you must pay really big attention on which version of the library versus which version of the SDK you use, otherwise you will quite surely incur in linking errors when you build your titanium applications. For instance, this short tutorial is proved to work with version 16 (git hash ad8053020d) of the library,  which is used by the version 2.0.0 of the Ti SDK.</p>

<p>For 1.8.X versions of the Ti SDK you should use version 15 of the library by checking out the git tag named <code>TiCore-15</code> in the <code>tijscore</code> repository, e.g.:</p>

<pre><code>git checkout TiCore-15
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/building-titanium-mobile-jscore-from-source/">Building Titanium Mobile JSCore From Source</a></h1>
    
    
      <p class="meta">
        




  

<time datetime="2012-03-02T16:20:00+01:00" pubdate>Mar 2<span>nd</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>As I already mentioned <a href="http://titaniumninja.com/post/10559549700/fastdev-for-ios-how-it-works/">here</a>, the Titanium Mobile framework on iOS is based on <a href="http://trac.webkit.org/wiki/JavaScriptCore">JavaScriptCore</a> (i.e. the engine used by WebKit) for interpreting and executing your app&#8217;s JS files.</p>

<p>Since part of my everyday work consists in hacking with the Ti SDK internals and building native modules it often happens that I need to track a bug or an issue down inside the core functions of the framework, and sometimes it would be useful to just take a look at the internal state of the JavaScript engine, in order to have a more detailed vision on where the problem at hand comes from.</p>

<p>However, the JSCore library (<code>libTiCore.a</code>) shipped with the Titanium SDK, is built in <em>Release</em> mode, with debug symbols stripped out, so, while its method and function names appear in a debug stack trace, it&#8217;s nearly impossible to look at actual variable and class member values.</p>

<p>Fortunately the source code of the library, customized by Appcelerator for integrating it with Titanium, is <a href="https://github.com/appcelerator/tijscore">available on github</a>, so we can create a custom build of it (e.g. a Debug version) and use it for our purposes.</p>

<p>Historically, building the library from scratch has not been much simple, nor documented. Moreover, since the process relied on several shell scripts, it was quite easy to get lost (at least at a first glance). However, in the last few months both Stephen Tramer and Blain Hamon (who are the main contributors to that code base) made a great work in simplifying and linearizing the build process.</p>

<p>This post aims at being just a quick tutorial for anyone needing to build <code>libTiCore</code> from scratch, so let&#8217;s dig in.</p>

<h2>Building the libTiCore.a library</h2>

<p>As usual, we can pull the git repo with:</p>

<pre><code>git clone https://github.com/appcelerator/tijscore.git
</code></pre>

<p>Once downloaded, in the <code>tijscore</code> directory we&#8217;ll find a couple of scripts, namely <code>fixup.py</code> and <code>buildit.sh</code> and the <code>TiCore</code> directory, which contains the original files from the JSCore sources.</p>

<p>In order to build the library we first need to run:</p>

<pre><code>./fixup.py
</code></pre>

<p>This script will patch most of the files in the TiCore directory, by changing names of files and symbols according to the Titanium namespace <strong>Ti</strong>, which is the one expected by the Ti SDK source code.</p>

<p>Then we can go with</p>

<pre><code>./buildit.sh
</code></pre>

<p>This script will build the library and create a universal binary for the armv6, armv7 and i386 architectues. The build process is quite long (a bunch of minutes on my i7 MacBook Pro) and you&#8217;ll notice it&#8217;s completed when you hear the cooling fans of your computer stop whirling like crazy.</p>

<p>The <code>buildit.sh</code> script also accepts a <em>CONFIG</em> parameter that we can use for instructing it to build a debug version of the library:</p>

<pre><code>./buildit.sh Debug
</code></pre>

<p>Once the build process is completed you&#8217;ll find the <code>libTiCore.a</code> library binary in the <code>TiCore/build</code> directory. The last required step is to install it in the appropriate folder of the Ti SDK:</p>

<pre><code>cp TiCore/build/libTiCore.a $TITANIUM_DIR/mobilesdk/osx/$TITANIUM_VERSION/iphone/
</code></pre>

<p>where <code>$TITANIUM_DIR</code> and <code>$TITANIUM_VERSION</code> are respectively the root directory of your Ti SDK and the version you are currently using, e.g. <code>/Library/Application\ Support/Titanium</code> and</p>

<h2>A note on libTiCore.a versions vs Ti SDK versions</h2>

<p>The Titanium Mobile SDK and the TiCore library are not really independent, so you must pay really big attention on which version of the library versus which version of the SDK you use, otherwise you will quite surely incur in linking errors when you build your titanium applications. For instance, this short tutorial is proved to work with version 16 (git hash ad8053020d) of the library,  which is used by the version 2.0.0 of the Ti SDK.</p>

<p>For 1.8.X versions of the Ti SDK you should use version 15 of the library by checking out the git tag named <code>TiCore-15</code> in the <code>tijscore</code> repository, e.g.:</p>

<pre><code>git checkout TiCore-15
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/simulating-slow-network-links-on-os-x/">Simulating Slow Network Links on OSX</a></h1>
    
    
      <p class="meta">
        




  

<time datetime="2011-10-31T21:19:00+01:00" pubdate>Oct 31<span>st</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Testing mobile apps in the target platform simulator (either iOS or Android) can often be misleading, since the provided environment is an ideal one. The result is that an app working perfectly when executed in an emulated sandbox may expose unintended behaviors and perfomance when executed in open field on a real device. Moreover, not only physical resources, like processor performance and available memory are very different: also the characteristics of the  network connection available to a development machine (i.e. wifi attached to a DSL or better link) usually outperform those of the mobile Internet links available in the wild, usually ranging from no connection at all to different kinds of 3G connections.</p>

<p>Several techniques do exist for simulating more realistic network characteristics when testing mobile apps on OS X, however most of them leverage the <em>traffic shaping</em> capabilities of the <code>ipfw</code> builtin firewall. In particular, they use the <code>ipfw pipe</code> command, which allows to define a pipe where all or part of the network traffic originating from, or directed to the host will be forced into.</p>

<p>The characteristics of the pipe can be shaped according to specific requirements in terms of bandwidth, delay and packet-loss-ratio of the link that needs to be modeled, thus enabling a high flexibility. A pipe can be configured through the following command:</p>

<pre><code>ipfw pipe &lt;num&gt; config bw &lt;bw&gt; delay &lt;d&gt; plr &lt;plr&gt;
</code></pre>

<p>where <code>num</code> is a number identifying the pipe, <code>bw</code> the desired bandwidth measured in <code>[K|M]{bit/s|Byte/s}</code>, <code>delay</code> is the propagation delay measured in milliseconds, and <code>plr</code> is the packet-loss-ratio, i.e. a number in the range [0..1].</p>

<p>The following adds a firewall rule for the pipe:</p>

<pre><code>ipfw add &lt;rule-num&gt; pipe &lt;num&gt; &lt;protocol&gt; from &lt;src&gt; to &lt;dst&gt;
</code></pre>

<p>The meaning of the command is the following:</p>

<pre><code>* add rule with number rule-num
* get all the packets containing protocol and directed from src to dst
* flow them through the pipe identified by num
</code></pre>

<p>For example, modeling a GPRS link could be done with:</p>

<pre><code>sudo ipfw pipe 1 config bw 56Kbit/s delay 200 plr 0.2
sudo ipfw add 1 pipe 1 ip from any to any
</code></pre>

<p>which forces all the ip traffic through a 56Kbps link with a 200ms delay, which loses 20 packets out of 100 in average.</p>

<p>It should be noted that while the rule is enforced, <strong>all</strong> the network traffic generated from or directed to the host machine is affected. Once the testing has been performed, the rule can be deleted with the command:</p>

<pre><code>sudo ipfw delete 1
</code></pre>

<p>Not all network links have symmetric characteristics. In those cases it&#8217;s possible to model in a different way the uplink and the downlink sections with the following rules:</p>

<pre><code>sudo ipfw pipe 1 config bw 780Kbps delay 100
sudo ipfw pipe 2 config bw 330Kbps delay 100
sudo ipfw add 1 pipe 1 in proto ip
sudo ipfw add 1 pipe 2 out proto ip
</code></pre>

<p>More details can be found in the <a href="http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man8/ipfw.8.html">ipfw man page</a> and in the original <a href="http://info.iet.unipi.it/~luigi/dummynet/">Dummynet project</a> page.</p>

<p>Using this technique from the command line, while effective, is probably not much practical. Moreover, figuring out realistic values for the required parameters can be a quite difficult task. A help in overcoming these issues comes from the developer tools available with XCode 4.2 on OS X Lion that, among others, provide a system preference pane called &#8220;Network Link Conditioner&#8221;, which allows to perform the same operations I listed before through a simple GUI, with a lot of predefined configuration templates.</p>

<p>The tool can be found here:</p>

<pre><code>/Developer/Applications/Utilities/Network\ Link\ Conditioner/Network Link Conditioner.prefPane
</code></pre>

<p>and once installed is made available in the System Preferences:</p>

<p><img class="center" src="/images/posts/NetConditionerSysPref.png"></p>

<p>The panel allows selecting a configuration from a list of presets, which comprise different kinds of mobile and &#8220;home&#8221; network links:</p>

<p><img class="center" src="/images/posts/NetConditioner.png"></p>

<p>The desired settings can be activated through the big switch present on the left of the panel and, in case the available presets are not sufficient, it&#8217;s possible to define custom configurations through the &#8220;Manage Profiles&#8221; button:</p>

<p><img class="center" src="/images/posts/NetConditionerManage.png"></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/post/10559549700/fastdev-for-ios-how-it-works">FastDev for iOS: How It Works</a></h1>
    
    
      <p class="meta">
        




  

<time datetime="2011-09-23T00:00:00+02:00" pubdate>Sep 23<span>rd</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Some days ago I <a href="http://titaniumninja.com/post/10360108035/titanium-hack-fastdev-for-ios">published</a> a hack that allows patching the Titanium Mobile SDK for enabling fast on-device testing of iOS applications, without needing to rebuild, sign and redeploy them.</p>



<p>With this post I&#8217;d like to share some of the inner workings of the Titanium sdk that make that hack possible. I also try to explain in more detail how the hack works, so you may want to check out its source code at <a href="https://github.com/omorandi/TiiOSFastDev"><a href="https://github.com/omorandi/TiiOSFastDev">https://github.com/omorandi/TiiOSFastDev</a></a>.</p>



<p>First, I need to say that, in contrast to what many developers believe when they first approach Titanium Mobile, the JavaScript files that compose an application are not compiled to native code. Instead they get interpreted by a JavaScript engine: a slightly modified version of <a href="http://">JavaScriptCore</a> on iOS (i.e. the engine used by WebKit), and <a href="http://www.mozilla.org/rhino/">Rhino</a> (which will be hopefully soon replaced by  <a href="http://code.google.com/p/v8/">V8</a>) on Android.</p>



<p>When deploying an application on the iOS emulator, the JS engine gets fed directly with the original files that reside in the <code>Resources</code> directory of your app project, loaded at runtime. This allows you for example to see the changes you made in one file, by just restarting the app in the emulator.</p>



<p>On the other hand, when deploying on the device, the original source files are processed and packed into a single file, just before building the app. 

This step generates the <code>build/iphone/Classes/ApplicationRouting.m</code> file, which is one of the very few that are dynamically generated by the build process. Indeed, most of the objective-c files that compose the native app are simply copied from the appropriate Ti SDK directory (e.g. <code>/Library/Application\ Support/Titanium/mobilesdk/osx/1.8.0</code>) into the <code>build/iphone</code> directory of the project by the titanium build scripts when you launch the app from Ti Studio, or from the command line.</p>



<p>Once generated, <code>ApplicationRouting.m</code> contains the definition of a dictionary object that associates the name of each JS file present in the Resources directory of your project with a binary representation of its original content, along with a single class method named <code>resolveAppAsset:</code> whose only purpose is to return the appropriate file content for a given path:</p>



<script src="https://gist.github.com/1237812.js?file=gistfile1.m"></script><p>In other words, this portion of code represents the point where the original content of each JS file is dispatched to the Titanium runtime environment, which will then feed it to the JSCore interpreter.</p>



<p>As you surely understand at this point, the FastDev hack is made possible by simply using a modified version of the <code>resolveAppAsset</code> method, which, instead of returning static data, opens a connection to an HTTP server running on the development machine for retrieving the original JS files from the Resources directory:</p>



<script src="https://gist.github.com/1237725.js?file=gistfile1.m"></script><p>Actually it&#8217;s that simple, however there are some caveats:</p>



<ol><li><p>Since the method is called synchronously, also the HTTP request must be performed in a synchrounous way:</p>



<p><code>[request startSynchronous];</code></p></li>

<li><p>For testing the application on the iOS emulator, the request to the server can be made on <code>localhost</code>, however, for on-device testing, we need to know in advance the IP address at which we the server can be reached, because the modified <code>ApplicationRouting.m</code> will be built into the native application running on the target device. This is achieved through a simple trick in the startserver.py script:</p></li>

</ol><script src="https://gist.github.com/1237809.js?file=gistfile1.py"></script><p>This code allows discovering the local IP address that routes to the Internet (specifically to gmail.com), so I make the assumption that the iPhone/iPad used for testing and the development machine reside both on the same local network and that the IP address of the Mac machine on that network is also the one that routes it to the Internet.</p>



<p>So the <code>startserver.py</code> script uses this information for patching the <code>build/iphone/Classes/ServerAddr.h</code> file containing  the <code>SERVER_ADDRESS</code> define, which is used in <code>ApplicationRouting.m</code> for creating the HTTP request. This is also why the <code>startserver.py</code> script needs to be launched before building the app.</p>



<p>That&#8217;s it!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/post/10360108035/titanium-hack-fastdev-for-ios">Titanium Hack: FastDev for iOS</a></h1>
    
    
      <p class="meta">
        




  

<time datetime="2011-09-18T00:00:00+02:00" pubdate>Sep 18<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Testing large Titanium Mobile applications on iOS devices can be cumbersome, since the build &amp; deploy process can take several minutes, even when the project is launched directly from XCode. Repeating the same process each time, for checking the effect of small modifications to the code is then quite annoying and time consuming.</p>



<p>I just posted a small project on github at <a href="https://github.com/omorandi/TiiOSFastDev"><a href="https://github.com/omorandi/TiiOSFastDev">https://github.com/omorandi/TiiOSFastDev</a></a> that aims at solving this issue.</p>



<p>It is a quite hackish solution that allows you to change on the fly the application resource files of your project and get them pulled by your app (either on device or simulator) without needing to rebuild it, sign it, and re-deploy it.</p>



<p>The solution consists in a bunch of scripts that perform these operations:</p>



<ol><li><p> patch your Titanium SDK folder (or, better, a copy of it)</p></li>

<li><p>start an HTTP server in the Resources directory of your Titanium Mobile project</p></li>

</ol><p>Once these steps are completed, you can build your app and deploy it to the device for testing. Should you find you need to fix some of your program files, just do it, manually restart the app, and proceed with testing, without needing to rebuild &amp; redeploy it.</p>



<p>This process is similar to the one involved using the fastdev feature for Android, however the mechanism is not managed by Titanium Studio, and involves a series of steps to be performed manually.</p>



<p>The Ti SDK patching script expects you to work with a 1.8.X Titanium Mobile SDK. It can be modified in order to work with 1.7.X versions, however this is not currently supported.</p>



<p>The http server is implemented as a simple node js script, so for executing it you need a working node environment in your system (you can grab it from <a href="http://nodejs.org/"><a href="http://nodejs.org/">http://nodejs.org/</a></a> ).</p>



<h1>How to use it</h1>



<p>First, check out the <a href="https://github.com/omorandi/TiiOSFastDev">TiiOSFastDev repository</a>  from github.</p>



<p>In the following steps I use the following symbols for the involved directories:</p>



<pre><code>$TI_FASTDEV_DIR (the directory containing this repository)

$TI_SDK_DIR (usually /Library/Application\ Support/Titanium)

$PRJ_DIR (The root directory of your Ti Mobile App project)

</code></pre>



<ol><li><p>Check out your Titanium Mobile directory under <code>$TI_SDK_DIR</code>. There you&#8217;ll find one or more directories of the SDKs installed in your system.</p></li>

<li><p>Create a copy of the SDK directory you want to patch and call it for example <code>1.8.0-fastdev</code> (actually you&#8217;ll want to keep the original SDK directory intact for the normal development workflow)</p></li>

<li><p>In a terminal window, go to the directory that contains the files of this repository (<code>$TI_FASTDEV_DIR</code>) and perform the following:</p>



<p><code>./patch.sh 1.8.0-fastdev</code></p></li>

<li><p>Launch your Ti Mobile application from Titanium Studio or through your preferred method. This is needed in order to re-create the <code>build/iphone</code> directory in your project, with the patched files. If this doesn&#8217;t happen, just clean the project and relaunch it</p></li>

<li><p>For your convenience, create an alias for the <code>startserver.py</code>script:</p>



<p><code>alias fdstart='$TI_FASTDEV_DIR/startserver.py'</code></p></li>

<li><p>Then <code>cd</code> in the <code>Resources</code> directory of your Titanium Mobile application project, for example:</p>



<p><code>cd $PRJ_DIR/Resources</code></p></li>

<li><p>Using the previously created alias, you can start the server with:</p>



<p><code>fdstart</code></p></li>

<li><p>That&#8217;s it, you can now restart the application from Ti Studio (if you want to use the simulator), deploy it on the device, or, better, build the app for device in XCode (by opening the XCode project you find in <code>$PRJ_DIR/build/iphone</code>, sign the product and install it on device. From now on your application JS files are pulled through the server you started in the <code>Resources</code> directory of your project.</p></li>

<li><p>Enjoy the time you have saved with this hack ;-)</p></li>

</ol><h1>Demo video</h1>



<p>I made a demo for showing how this hack can be used. Please note that when launching the project from XCode I select the Simulator target only for convenience (it&#8217;s not that easy to show the iphone screen output in a screencast):</p>



<iframe src="http://player.vimeo.com/video/29218138?title=0&amp;byline=0&amp;portrait=0" width="400" height="300" frameborder="0" webkitallowfullscreen allowfullscreen></iframe>



<p><a href="http://vimeo.com/29218138">Titanium Mobile iOS FastDev hack demo</a> from <a href="http://vimeo.com/user8368459">Olivier Morandi</a> on <a href="http://vimeo.com">Vimeo</a>.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/post/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/using-a-custom-build-of-jscore-in-titanium-ios/">Building Titanium Mobile JSCore from source</a>
      </li>
    
      <li class="post">
        <a href="/building-titanium-mobile-jscore-from-source/">Building Titanium Mobile JSCore from source</a>
      </li>
    
      <li class="post">
        <a href="/simulating-slow-network-links-on-os-x/">Simulating slow network links on OSX</a>
      </li>
    
      <li class="post">
        <a href="/post/10559549700/fastdev-for-ios-how-it-works">FastDev for iOS: how it works</a>
      </li>
    
      <li class="post">
        <a href="/post/10360108035/titanium-hack-fastdev-for-ios">Titanium Hack: FastDev for iOS</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Coderwall</h1>
  <p>
  <script type="text/javascript">
    function display_coderwall(args) {
        var badges = args["data"]["badges"];
        for ( var i = 0; i < badges.length; i++ ) {
            document.write('<img src="'+ badges[i]["badge"] + '" width="80" height="80" />');
        }
    }
  </script>
  <script src="http://coderwall.com/omorandi.json?callback=display_coderwall"></script>
  </p>
  <p style="text-align: right;"><a href="http://coderwall.com/omorandi">Powered by coderwall.com</a></p>
</section>

<section>
  <h1>Github Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/omorandi">@omorandi</a> on Github
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'omorandi',
            count: 3,
            skip_forks: true,
            target: '#gh_repos',
            to_hide: ['omorandi.github.com', 'TiImageSlices']
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("olivier_morandi", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/olivier_morandi" class="twitter-follow-button" data-width="208px" data-show-count="false">Follow @olivier_morandi</a>
  
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - TiNinja -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
