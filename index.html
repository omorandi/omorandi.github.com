
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Titanium Ninja</title>
  <meta name="author" content="TiNinja">

  
  <meta name="description" content="My Titanium/iOS development workflow mainly revolves around using Sublime Text for code editing, and the Titanium CLI and Xcode for testing/ &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://titaniumninja.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="http://feeds.feedburner.com/TitaniumNinja" rel="alternate" title="Titanium Ninja" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href='http://fonts.googleapis.com/css?family=Alike+Angular' rel='stylesheet' type='text/css'>
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-8810685-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Titanium Ninja</a></h1>
  
    <h2>App and module development with Titanium Mobile</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="http://feeds.feedburner.com/TitaniumNinja" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:titaniumninja.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/whoami/">whoami</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/debugging-titanium-apps-with-chrome-devtools/">Debugging Titanium Apps With Chrome DevTools</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-13T18:23:00+02:00" pubdate data-updated="true">Jul 13<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>My Titanium/iOS development workflow mainly revolves around using Sublime Text for code editing, and the Titanium CLI and Xcode for testing/deployment/debugging. However, sometimes this setup isn&#8217;t sufficient, especially when I need to inspect what happens in an application at the JavaScript level. In these cases there are basically two choices:</p>

<ul>
<li>fill the code with logging statements</li>
<li>use the JavaScript debugger integrated in Titanium Studio</li>
</ul>


<p>It turns out that there are times when none of these techniques is satisfying: using logging statements is a quick and dirty technique, but it can lead to long modify/rebuild/test iterations, before finally finding the right spot in the code that&#8217;s causing an issue. Using a proper debugger, like the one provided by Ti Studio is surely the way to go in most cases, however, switching back to Studio just for debugging can be a painfully slow operation. In other words, I needed a more &#8220;agile&#8221; way to start a debugging session.</p>

<h2>Enter Ti Inspector</h2>

<p><a href="https://github.com/omorandi/TiInspector">Ti Inspector</a> is a tool I had a lot of fun building over the past few months, which allows debugging a Titanium app (only on iOS for the moment) through the Chrome DevTools debugging interface, i.e. the same panel that can be opened for inspecting and debugging a web page in Google Chrome (e.g. right-click on the page, then Inspect Element).</p>

<p>How was this possible? Actually, the <a href="https://developers.google.com/chrome-developer-tools/">DevTools panel</a> provided by Chrome is nothing more than a pure HTML+CSS+JS web application, whose source code is part of the <a href="http://www.chromium.org/blink">Blink</a> project, i.e. the fork of the WebKit rendering engine that Google recently started. When opened inside of Chrome, the DevTools front-end directly communicates with the Chrome internals through a series of JS to native bindings, however it can also be used in a remote debugging setup, where the front-end is served from and connects to a remote Chrome instance, running a web application we want to inspect. In particular, the DevTools front-end application expects to communicate with a remote backend counterpart through a websocket connection, implementing a JSON-based RPC protocol, which is documented in detail <a href="https://developers.google.com/chrome-developer-tools/docs/debugger-protocol">here</a>.</p>

<p>On the other side we have our Titanium application running (e.g. on the iOS simulator), which integrates a debugger agent that is able to interact with the engine used for executing our JavaScript code (e.g. JavaScriptCore on iOS). If enabled, the debugger agent expects to communicate through a <a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Debugger_Protocol-section-30083170_DebuggerProtocol-Variablepropertyflags">TCP-based protocol</a> with its front-end counterpart, which is normally represented by the Titanium Studio debugger interface. Titanium Studio silently enables this mechanism when we build for debugging, by appending a <code>--debug-host</code> argument to the Titanium CLI invocation, for example:</p>

<pre><code>titanium build --platform ios --debug-host localhost:54321
</code></pre>

<p>Ti Inspector is the tool that allows these two worlds to successfully communicate, acting as a gateway between the Chrome DevTools remote debugging protocol and the Titanium debugger protocol. It does so by the means of a node.js based application, which implements the following mechanisms:</p>

<ul>
<li>It serves the DevTools web app from the default port 8080</li>
<li>It listens for tcp connections on the default port 8999, where the Ti debugger agent will connect once the app starts</li>
<li>It accepts websocket connections from the DevTools app</li>
<li>Once both the debugger agent and DevTools app are connected, Ti Inspector translates commands, replies and asynchronous events from one protocol to the other, doing additional book-keeping and translating the descriptors of the necessary model elements (i.e. scripts, breakpoints, stack frames, variables, etc.).</li>
</ul>


<h2>How to use it</h2>

<p>Ti Inspector is a node.js module, so as a basic prerequisite a working node.js setup is needed, then we can use npm for installing it globally:</p>

<pre><code>$ [sudo] npm install -g ti-inspector
</code></pre>

<p>Once installed, we can <code>cd</code> to any Titanium Mobile application project directory and launch the <code>ti-inspector</code> command:</p>

<pre><code>$ cd /path/to/your/titanium/project/directory
$ ti-inspector
</code></pre>

<p>doing so, a web server starts listening on port 8080, and a debug server is attached to TCP port 8999.
Pointing a browser on <code>localhost:8080</code> we&#8217;ll get a page with a brief description of our application, telling that no active debug sessions are active. At this point, we can start our application through the Titanium CLI, specifying that the debug agent running in the app will need to connect to port 8999 on the localhost, for example:</p>

<pre><code>$ titanium build -p iphone --tall --retina --debug-host localhost:8999
</code></pre>

<p>Once the app will start in the iOS Simulator, the debugger will connect with Ti Inspector and a new debugging session will be created. In the browser we can then start the DevTools app and start debugging.</p>

<p>Anyway, sometimes a screencast is better then thousand words, so you can check out this short demo:</p>

<iframe src="http://player.vimeo.com/video/70244213" width="500" height="305" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p> <p><a href="http://vimeo.com/70244213">Ti Inspector Demo</a> from <a href="http://vimeo.com/user8368459">Olivier Morandi</a> on <a href="https://vimeo.com">Vimeo</a>.</p></p>

<h2>Features</h2>

<p>Ti Inspector supports almost all the JavaScript debugging features made available by the &#8220;Sources&#8221; panel of the Chrome DevTools interface except the features that are tied specifically to the web environment (e.g. DOM, XHR, EventListener breakpoints and WebWorkers sub-panels). In particular it supports the following:</p>

<ul>
<li>Breakpoints: setting/removing breakpoints, conditional breakpoints</li>
<li>Call stack inspection (when execution is suspended)</li>
<li>Variables and objects inspection</li>
<li>Watch expressions</li>
<li>Step operations (step over, step-into, step-out)</li>
<li>Console logging</li>
<li>Expression evaluation in the console (only when execution is suspended)</li>
<li>Suspend on exceptions (disabled by default)</li>
</ul>


<h2>Limitations</h2>

<p>Ti Inspector is currently at an alpha stage of development. Some features are still missing and will be possibly added as they become indispensable (e.g. Android emulator support), while others will probably never taken into consideration (e.g. on device debugging).</p>

<p>For completeness, some of the current limitations are the following:</p>

<ul>
<li>Android is not currently supported: for debugging Android Apps, Titanium Studio does more heavy lifting and the Ti debugger protocol is somewhat translated into the V8 debugging protocol by an internal component. This means that supporting Android will mean implementing the <a href="https://code.google.com/p/v8/wiki/DebuggerProtocol">V8 remote debugging protocol</a> in Ti Inspector. This is something I&#8217;ll likely work on in the near future</li>
<li>On device debugging is not supported since it&#8217;s treated in a special way by the CLI and Studio.</li>
<li>Expressions can only be evaluated when the execution is suspended</li>
</ul>


<h2>Source code</h2>

<p>The source code is completely available <a href="https://github.com/omorandi/TiInspector">on GitHub</a> under the MIT license. Issue postings and pull requests are very welcome.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/ticonf-2013-and-new-titanium-modules/">tiConf 2013 and New Titanium Modules</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-07T16:55:00+01:00" pubdate data-updated="true">Mar 7<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><center><a href="http://www.flickr.com/photos/93283347@N02/8517412475/" title="@oliviermorandi Discusses native module creation by tiConf EU 2013 / Tipsy &amp; Tumbler Ltd, on Flickr"><img src="http://farm9.staticflickr.com/8241/8517412475_21881b0207.jpg" width="500" height="333" alt="@oliviermorandi Discusses native module creation"></a><br>Courtesy <a href="http://www.tipsyandtumbler.co.uk/">Tipsy &amp; Tumbler Ltd</a>
</center>


<br>


<p>Almost two weeks ago I had the pleasure to attend <a href="http://ticonf.eu">tiConf 2013</a> in Valencia, where, besides getting in touch with lots of awesome developers from all over the world, I held a workshop on native module development for Titanium on both iOS and Android platforms. Here&#8217;s the presentation:</p>

<center><iframe src="http://www.slideshare.net/slideshow/embed_code/16780042" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/omorandi/ticonf" title="Extending Titanium with native iOS and Android modules " target="_blank">Extending Titanium with native iOS and Android modules </a> </strong> from <strong><a href="http://www.slideshare.net/omorandi" target="_blank">omorandi</a></strong> </div></center>




<br>


<p>During the talk I gave a quick tour on how to start creating modules, with an emphasis on how JS-to-native bindings are structured in the Titanium framework, presenting a set of real-world use cases. Among the others, I mentioned a module for offloading to native code the conversion of XML documents into JSON structures, which wasn&#8217;t yet published.</p>

<p>I had this module lying around for several months, so in the past few days I took some time to polish the iOS version and I published it on GitHub here: <a href="https://github.com/omorandi/TiXml2Json">github.com/omorandi/TiXml2Json</a>. I think it represents a very good start for understanding some of the concepts around Titanium native module creation.</p>

<p>But why shall we need such kind of functionality implemented in native code in the first place? Actually, parsing XML structures through the DOM API is somewhat cumbersome and inefficient, while working with JSON structures is more easily manageable. For doing this we could use any of the JavaScript modules available, like the good <a href="https://github.com/dbankier/XMLTools-For-Appcelerator-Titanium">XMLTools from David Bankier</a>, however, when the size of the XML string is relevant, the parsing phase can be very slow, thus blocking the execution of our app for a significant and noticeable amount of time. A possible solution is then to do the conversion in native land, achieving better performance. In some cases this may still not be enough, so I also implemented an asynchronous version of the conversion method, which offloads the conversion process on a separate thread, keeping the JavaScript thread free to continue its normal flow, thus adding responsiveness to the client application.</p>

<p>The module exports a very simple API with just two methods:</p>

<ul>
<li><code>convert(xml)</code></li>
<li><code>convertAsync(xml, callback)</code></li>
</ul>


<p>The former takes an xml string or blob argument and returns the corresponding JSON representation as a JS object. The latter implements the asynchronous version described above, which takes an additional argument for the callback function that will be invoked with the resulting JS object at the end of the process. Internally, the conversion methods use the <a href="http://troybrant.net/blog/2010/09/simple-xml-to-nsdictionary-converter/">XML to NSDictionary converter</a> code from Troy Brant.</p>

<p>This week I also published another iOS module: <a href="https://github.com/omorandi/TiAssetsLibrary">TiAssetsLibrary</a>, which wraps the <a href="http://developer.apple.com/library/ios/#documentation/AssetsLibrary/Reference/AssetsLibraryFramework/_index.html">iOS AssetsLibrary framework</a> with an almost 1 to 1 mapping between the JS and the native API. This module deserves another post where I&#8217;d like to talk about performance implications of API design.</p>

<p>That&#8217;s all for now. See you all at the next <a href="http://ticonf.eu">tiConf</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/introducing-tiprofiler-for-ios/">Introducing TiProfiler for iOS</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-07-27T16:35:00+02:00" pubdate data-updated="true">Jul 27<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Around four months ago I started experimenting with some <a href="http://titaniumninja.com/profiling-ti-mobile-apps-is-it-possible/">custom modifications</a> to the  JavaScriptCore library, which is the JavaScript engine used by the Titanium Mobile SDK for executing Titanium applications on iOS. After succeeding in enabling the profiler component provided by JSCore and extracting some relevant profiling data from running applications, I wanted a tool that would allow me to show such information in a manageable way, like the Web Inspector and Developer tools allow to do in Safari or Chrome.</p>

<p>My basic requirements were the following:</p>

<ul>
<li>The tool needed to be able to start and stop the profiler running alongside a Titanium Mobile application executed on the iOS Simulator, as well as to retrieve the collected profiling data</li>
<li>The GUI app should be very simple and quick and easy to develop: a web app would be good enough</li>
<li>I wanted to be able to show the profiling data (i.e. a function call tree showing the amount of time spent in each function) in the typical expandable tree grid</li>
<li>I wanted to be able to quickly show the source code of every referenced function, in order to better understand the data every time an anonymous function was reported</li>
</ul>


<p>So I started creating a very simple web-based GUI and a node.js server component providing a proxy between the client app and the profiler, and today I&#8217;m able to introduce some results, with the following demo screencast:</p>

<iframe src="http://player.vimeo.com/video/46148981" width="500" height="313" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p> <p><a href="http://vimeo.com/46148981">TiProfiler demo</a> from <a href="http://vimeo.com/user8368459">Olivier Morandi</a> on <a href="http://vimeo.com">Vimeo</a>.</p></p>

<p>This has been possible thanks to the following technologies/libraries:</p>

<ul>
<li><a href="http://www.sencha.com/products/extjs/">Ext JS</a>: General GUI layout &amp; tree-grid</li>
<li><a href="http://ace.ajax.org/">ACE editor</a>: for showing the original source code of the selected application files</li>
<li><a href="http://socket.io/">socket.io</a>: for event-based communication between all the components</li>
</ul>


<p>The screencast showcases the usage of the three main components involved:</p>

<ul>
<li>The node-based server, used for serving the client app files and for communicating  with both the profiler and the GUI</li>
<li>The GUI app itself</li>
<li>The Titanium Mobile application, built and executed through a custom version of the 2.1.0.GA Titanium SDK, with all the required additions to make the magic possible</li>
</ul>


<p>The node server gets notified when the Titanium application and the profiler are started, re-broadcasting such events.
The web-app, on the other side, issues start &amp; stop commands to the node server, which reflects them to the profiler running inside of the Ti app.</p>

<p>At the core of the system lies a custom version of the TiJSCore library, and some very limited additions to the inner workings of the Titanium Kroll bridge. In particular, besides the basic modifications already mentioned in the <a href="http://titaniumninja.com/profiling-ti-mobile-apps-is-it-possible">previous post</a>, it has been necessary to do the following:</p>

<ul>
<li>modifying the code managing the CommonJS <code>require()</code> function, in order to make both the JS interpreter and the profiler aware of the names of the files being loaded through it</li>
<li>decorating the calls to methods of Titanium proxy objects with a representation of their real name, in order to highlight them with something more meaningful than <code>(Function oject)</code>. For example a call to <code>Ti.UI.Window.open()</code> now it&#8217;s reported as <code>[object TiUIWindow].open</code>: not exactly the JavaScript signature, but quite similar, indeed</li>
<li>building a bit of infrastructure in order to allow the profiler to communicate remotely, either for receiving <code>start</code> and <code>stop</code> commands, either for sending the recorded profiling data. Using the <a href="https://github.com/pkyeck/socket.IO-objc">iOS port of the socket.io library</a> helped a lot in this context.</li>
<li>other minor adjustments (e.g. converting profiling data returned by the JSCore profiler to JSon)</li>
</ul>


<p>At the moment I&#8217;m not planning to release these modifications and additions as open source. I&#8217;m still thinking about what to do about them. Actually it would be nice if at some point they could be integrated into the Titanium SDK.</p>

<p>Anyway, I&#8217;m willing to share this tool with the Titanium community, letting interested folks to play with it, and report any kind of feedback, so I&#8217;ve created a <a href="https://github.com/omorandi/TiProfiler">repository on github</a> hosting both the node server and the client app source code.</p>

<p>Originally I was aiming to keep all the modifications to the JSCore library, as well as the corresponding hooks inside the Titanium SDK completely self-contained in a single binary, in order to be able to provide just a simple drop-in replacement for the <code>libTiCore.a</code> library, to be plugged in a standard distribution of the Ti SDK. However, after integrating <code>socket.io</code> on the iOS side, things are a bit more complicated, since <code>socket.io</code> requires the target app to be linked with the Security framework, which is not linked by default in the standard Titanium Xcode template. For this reason, in order to keep things super-simple for anyone interested in this project, I&#8217;ve prepared a package containing a <a href="https://s3.amazonaws.com/titaniumninja/tiprofiler/2.1.0.GA-profiler.zip">custom version of the 2.1.0.GA Titanium SDK</a> that can coexist side by side with the official SDKs provided by Appcelerator already present in the system.</p>

<p>Anybody wanting to follow all the steps, without using the prebuilt package, can download a <a href="https://s3.amazonaws.com/titaniumninja/tiprofiler/libTiCore.a.zip">custom build of the libTiCore.a library</a>, copy it in the <code>${TI_SDK}/iphone</code> directory of a 2.X.X version of the Ti SDK (where <code>${TI_SDK}</code> for example is <code>/Library/Application\ Support/Titanium/mobilesdk/osx/2.1.0.GA</code>, open the <code>${TI_SDK}/iphone/iphone/Titanium.xcodeproj</code>) and add there a reference to the Security framework.</p>

<p>The custom SDK can be used for building, executing and profiling any Titanium application on iOS, with the following, and maybe more, limitations:</p>

<ul>
<li>It doesn&#8217;t work for Android targets</li>
<li>It can be used only with apps running inside the iOS Simulator:  apps should be able to execute on device, but at the moment, no profiling data can be exchanged with the node.js server component. Results of building and running Ti apps on device with such SDK are currently undefined</li>
<li>The client app is currently very limited</li>
</ul>


<h2>Wrap up</h2>

<p>Where do we go from here?</p>

<p>I have a bunch of things I&#8217;d like to improve/work on in the very near future. Here are some:</p>

<ul>
<li>Replace the currently very limited web-app with the client from the <a href="https://github.com/dannycoates/node-inspector/">Node Inspector</a> project. This is actually a fork of the WebKit Web Inspector that can be used to debug and experimentally profile node.js applications. Modifying this to work with my server should be fairly easy</li>
<li>Improve the way in which anonymous functions are reported. It is true that these functions are actually unnamed, but in most cases they&#8217;re usually referenced through a variable or an object member. I&#8217;d like to leverage the features of the super-cool <a href="http://esprima.org/">Esprima</a> JavaScript parser in order to extract such information directly from source files, reporting the name of the referencing variable/member when possible</li>
<li>Make things work on device</li>
<li>Start studying how to do something similar on V8 for android targets</li>
</ul>


<p>Any comment is well accepted, either here, or on <a href="http://twitter.com/olivier_morandi">twitter</a>. This project is needing some love, especially on the GUI component and node server side. Feel free to fork it on github and make pull requests.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/testing-titanium-mobile-applications-with-jasmine-and-sinon-part-i/">Testing Titanium Mobile Applications With Jasmine and Sinon (Part I)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-11T18:16:00+02:00" pubdate data-updated="true">Jun 11<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>As the code base of an application grows, manual testing becomes very quickly a cumbersome and highly error prone activity. Moreover, when fixing bugs or refactoring portions of the app, there&#8217;s no way for telling if a fix is breaking something that was previously working. In order to mitigate such drawbacks, automatic unit testing tools come at help, allowing to describe how each single component of an application must behave, and testing in a systematic way if the imposed requirements and expectations are met.</p>

<p>During the last year, which I mainly spent developing and maintaining a quite large and complex Ti Mobile application, I tried to investigate which were the available options for gradually introducing automatic testing in my development workflow. There is plenty of tools and frameworks for Javascript testing, and although most of them are obviously targeted to the web development world, some of them have been more or less successfully made available for testing Titanium Mobile applications.</p>

<p>JS dynamic nature makes it an ideal language for automatic testing: you can easily modify objects at runtime, and provide fake implementations around the code that needs to be tested. So testing JS applications, and in particular Ti Mobile applications is super easy, right? Wrong! Or better, it can be, provided that you use the right tools and that you write your code in a way that makes it easily testable. For instance, every time we use state variables and functions hidden inside closures (e.g. even just using either CommonJS, or the omni-present <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript">module pattern</a>), we are creating code that can be hard to test. An interesting take on this problem can be found <a href="http://www.adequatelygood.com/2010/7/Writing-Testable-JavaScript">here</a>.</p>

<p>In this short series of post I&#8217;d like to talk about some tools and patterns I&#8217;ve found useful for introducing automatic testing in my coding/refactoring habits.</p>

<h2>The tools</h2>

<p>There are quite <a href="http://en.wikipedia.org/wiki/List_of_unit_testing_frameworks#JavaScript">a lot</a> JavaScript testing frameworks available, some of which are dependent on the presence of a DOM, so they&#8217;re only suitable for in-browser testing and cannot be used in Titanium. Among those that are framework-independent I&#8217;ve found <a href="http://pivotal.github.com/jasmine/">Jasmine.js</a> very interesting. Jasmine is a self-contained <a href="http://dannorth.net/introducing-bdd/">Behaviour-Driven Development</a> (BDD) framework for Javascript, where tests express the &#8220;expected behaviour&#8221; for our code. I won&#8217;t go into detail on the philosophy behind this kind of Test-Driven Development practice, but those willing to dig deeper will find the <a href="http://pragprog.com/book/achbd/the-rspec-book">&#8220;RSpec Book&#8221;</a> quite useful.</p>

<p>There exist a bunch of attempts bring BDD testing with Jasmine to Titanium:</p>

<ul>
<li><a href="https://github.com/akahigeg/jasmine-titanium">akahigeg Jasmine-Titanium (github)</a></li>
<li><a href="https://github.com/guilhermechapiewski/titanium-jasmine">guilhermechapiewski Titanium-Jasmine (github)</a></li>
<li><a href="http://www.singingseal.com/dev/titanium-and-jasmine/">Cross-platform, Testable Mobile Goodness with Titanium and Jasmine</a></li>
<li>probably others more recentsâ€¦</li>
</ul>


<p>I have tried each of these approaches and none satisfied me. In particular, the second solution, which is probably the most used among the Ti community and is based on running tests directly in the target simulator, dissatisfied me for the following reasons:</p>

<ul>
<li>Testing in the simulator is very slow, while TDD is based on quick <a href="http://en.wikipedia.org/wiki/Test-driven_development#Development_style">red/green/refactor</a> iterations, where you first write the test for your code, you make it fail, you refactor and iterate until you get a green light. Even if, like me, you don&#8217;t follow religiously this practice, you quickly lose your patience waiting for the simulator to start every time</li>
<li>I think that testing in the simulator, while surely necessary at some point (mainly while doing integration and acceptance testing), allows taking short paths that quickly lead to writing poorly testable code (more on this later)</li>
</ul>


<p>Actually what I was looking for was a solution allowing me to write and execute my tests in the quickest and simplest way possible. Enter <a href="http://en.wikipedia.org/wiki/Test-driven_development#Development_style">Jasmine-Node</a>, which is a Node.js module, providing a cli for running Jasmine tests through node.</p>

<h3>Jasmine-node: setup &amp; execution</h3>

<p>Supposing you already have Node.js and npm in place, installing jasmine-node is just a matter of typing:</p>

<pre><code>$ sudo npm install jasmine-node -g
</code></pre>

<p>Now you can start executing your tests (also called <em>specs</em>), whose JS files should reside all in the same directory tree. For example, let&#8217;s consider the following directory tree, which could be part of a Ti Mobile project:</p>

<pre><code>project/
|     
+---- Resources/
|     |
|     +---- app.js
|     |
|     +---- app-modules/
|           |
|           +---- backend.js
|           |
|           +---- ui.js
|
+---- spec/
      |
      +---- backend_spec.js
      |
      +---- ui_spec.js
</code></pre>

<p>In <code>Resources</code> we have the application code, contained in a couple of CommonJS modules. Our tests reside in the <code>spec</code> directory. Please note that each file in this directory contain the <code>spec</code> string in its name, allowing jasmine-node to recognize it as a file to be evaluated by the test runner.</p>

<p>Having in mind this directory structure, we can execute our tests (e.g. from inside the <code>project</code> dir):</p>

<pre><code>$ jasmine-node spec
.............

Finished in 0.013 seconds
13 tests, 15 assertions, 0 failures
</code></pre>

<p>the command argument is simply the path of the directory containing our tests.</p>

<h3>Let&#8217;s write some code and some tests</h3>

<p>Now, we can write our code and our tests. For example, suppose in our app we have a module with some silly utility functions:</p>

<pre><code>project/Resources/app-modules/util.js:
--------------------------

exports.computeSum = function(a, b) {
    return a + b;
};
</code></pre>

<p>we can write our Jasmine spec like this:</p>

<pre><code>project/spec/util_spec.js:
--------------------------

var util = require('../Resources/app-modules/util');
describe('util tests', function() {

    it('should compute the sum between 1 &amp; 2', function(){
        var sum = util.computeSum(1, 2);
        expect(sum).toEqual(3);
    });

});
</code></pre>

<p>let&#8217;s run the spec:</p>

<pre><code>jasmine-node spec
.

Finished in 0.007 seconds
1 test, 1 assertion, 0 failures
</code></pre>

<p>I don&#8217;t enter in further details on how to write Jasmine tests, as this will be covered in the second part of this post (still to come);</p>

<p>We need to remember that specs must be written as Node.js modules and obviously the Titanium Mobile API objects won&#8217;t be available. So <strong>how can we test our Titanium modules if they make use of the Titanium API</strong>? We need to provide our tests with <em>fake</em> implementations of it. This subject leads to the concept of <a href="http://martinfowler.com/articles/mocksArentStubs.html">mocks and stubs</a> and <a href="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a>, which I&#8217;ll cover in the next episode.</p>

<h3>Caveats</h3>

<p>In this post we&#8217;ve just touched the basics about how to setup our environment for testing with node-jasmine and Titanium, however there are some somewhat hidden issues that need to be taken into account. In particular, it turns out that the Titanium implementation of CommonJS <code>require()</code> is <a href="https://jira.appcelerator.org/browse/TIDOC-514.">buggy</a> and doesn&#8217;t correctly support relative paths. This represents a major problem when trying to integrate jasmine-node test runners in projects with even minimally complex directory trees.</p>

<p>A possible solution to the issue is to not use relative paths in <code>require()</code> in Titanium (but you are free to use them in your jasmine specs run through node). Instead of relative paths we need to use full paths with <code>Resources</code> as the root directory.</p>

<p>For example, taking into account the directory tree laid out before, let&#8217;s suppose the <code>backend.js</code> module is dependent from the <code>util.js</code> module, we&#8217;ll need to write the <code>require()</code> in this way:</p>

<pre><code>project/Resources/app-modules/backend.js:
--------------------------

require('app-modules/util');

//...
</code></pre>

<p>In our jasmine specs we&#8217;ll use relative paths as usual.</p>

<p>Now the trick is to set the NODE_PATH environment variable to point to the <code>Resources</code> directory of the Ti Project, just like:</p>

<pre><code>export NODE_PATH="${PROJECT_DIR}/Resources"
jasmine-node spec   
</code></pre>

<p>This will instruct the Node.js environment to search for modules in the <code>Resources</code> directory, allowing them to be found by the test runner.</p>

<p>These two lines can obviously be encapsulated in a shell script or makefile.</p>

<h2>What next?</h2>

<p>In the next episode of this series, we&#8217;ll see how to write our application modules in Titanium, in order to make them easily testable. We&#8217;ll also expand our use of available testing frameworks, discussing how to use <a href="http://sinonjs.org/">Sinon.js</a> for creating <a href="http://martinfowler.com/articles/mocksArentStubs.html">mocks and stubs</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/titanium-mobile-flexibility-vs-performance/">Titanium Mobile: Flexibility vs. Performance</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-05-28T01:14:00+02:00" pubdate data-updated="true">May 28<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Last week I had the pleasure to give a talk at the <a href="http://www.whymca.org/">WhyMCA Italian Mobile Developer Conference</a>. The title of the talk is <a href="http://www.whymca.org/intervento/titanium-mobile-flexibility-vs-performance">&#8220;Titanium Mobile: Flexibility vs. Performance&#8221;</a>. Despite being structured as a quite technical speech, at it&#8217;s heart I consider it a &#8220;philosophical&#8221; one, since its message is highly related to why I think the approach to cross platform mobile development and code portability provided by Titanium is, albeit always perfectible, the right one. In this post I&#8217;d like to expand a bit on the motivations behind this line of thinking.</p>

<p>Titanium isn&#8217;t a write-once-run-everywhere platform. As Appcelerator&#8217;s guys use to say, its aim is to be a write-once-adapt-everywhere tool, since, while using a common high level language and API, it enables the exploitment of platform specific features when needed. This philosophy is clearly visible in the API, as we have entire sub-namespaces dedicated to either iOS, or Android. This allows adapting our mobile applications to the platforms where they&#8217;re executed, thus avoiding a write once, suck everywhere effect. Moreover, the possibility to develop custom native extensions to the framework opens  up a wide range of development scenarios, ideally allowing us to create user experiences that are practically undistinguishable from those of applications developed with native SDKs.</p>

<p>My point of view on this kind of approach to cross platform portability has its roots in the work I took over during 5 years as a researcher, where I explored the boundaries of flexibility (in terms of ease of development and cross platform portability) and performance in the field of network processing architectures. If you really have nothing better to do, you can check out my <a href="/doc/2009-PhD-MorandiOlivier.pdf">PhD dissertation thesis</a> dating back to the beginning of 2009 for additional details.</p>

<p>While at a completely different scale, in mobile application development we face challenges that are very similar to those that passionated me during my research:</p>

<ul>
<li>heterogeneous and incompatible mobile device platforms and OSs</li>
<li>while native capabilities are quite homogeneous across platforms, UIs are not</li>
<li>each platform must be programmed with it&#8217;s own SDK, each one based on a different language (e.g. Java for Android, objective-c for iOS, and so on) - code reuse and portability is impossible</li>
<li>we have stringent constraints on the User Experience: apps with a poor UX fail to gain wide adoption</li>
</ul>


<p>In this scenario, the approach proposed by Titanium is very interesting:</p>

<ul>
<li>It&#8217;s based on a high level language that abstracts away the different programming models of the target platforms</li>
<li>It provides a very wide and flexible <strong>high level</strong> API (in contrast to other technologies, like the very recent <a href="http://www.rubymotion.com/">RubyMotion</a>, which provides just Ruby wrappers around the classes of the iOS Cocoa Touch framework)</li>
<li>It&#8217;s extensible through natively coded modules for leveraging native features of the target platform</li>
</ul>


<p>Titanium applications are native by all means anyway, since even if written in JavaScript, they directly rely on native functionality. However, as its API is very general and flexible, allowing to adapt the same macro components to very disparate uses, in some cases this may cause slow downs and not so slick user experiences. It&#8217;s quite simple to explain why this happens: when the code implementing an UI component (e.g. a TableView), must be able to adapt to every possible use, we are introducing some amount of overhead, with the result of trading off performance in favor of flexibility.</p>

<p>So, in my presentation, I tried to propose two main lines of thought based on the realistic scenario of performance problems related to the creation and scrolling of a table view. The first line of thought tries to make the point that when we face a performance problem, which in mobile development is frequently a UX problem, we need to go to the root of the issue, by understanding what is causing it. This means the following things:</p>

<ul>
<li>we need to know how the tools we&#8217;re using actually work under the hood: Titanium doesn&#8217;t use the same JS engine on both iOS and Android. In particular, JavaScriptCore and V8 are very different implementations of JS, the latter being an optimizing JIT compiler, while the former is actually a bytecode interpreter, as JIT compilations is forbidden by iOS</li>
<li>As a corollary, relying on some old school micro-optimizations, like caching the length of an array while iterating over it in a for loop, may be actually useless, since if the body of the loop is &#8220;fat&#8221; enough, I&#8217;m quite sure you&#8217;re not wasting time in that check. Moreover, if that loop is &#8220;hot&#8221; enough, V8 will automatically optimize it anyway, by hoisting the access to the array length outside of the loop (check out this video from JSConf 2012: <a href="http://blip.tv/jsconf/jsconf2012-vyacheslav-egorov-6141593">&#8220;One day of life in V8&#8221; by Vyacheslav Egorov</a>)</li>
<li>We need to <strong>measure</strong>, at first even just in a rough way, in order to find where we are loosing time</li>
</ul>


<p>This last point raises an alert on the lack of accurate profiling tools that we can productively use for measuring the actual performance of our code. My extensions to Titanium for leveraging the <a href="/profiling-ti-mobile-apps-is-it-possible/">JavaScriptCore profiler</a> are still work in progress, and I&#8217;ll hopefully post an update on that story soon.</p>

<p>The other line of thought I pursued, is related to what we can do for increasing the scrolling performance of our table view component. Table views are a critical component in most applications, and those presenting complex row layouts can result in choppy scrolling animations for several reasons. Complex row layouts are actually a problem also when developed natively, however, in Titanium we have much less opportunities for optimizations, as we obviously need to rely on the provided API implementation, which is crafted in a way that enhances flexibility and ease of use for the developer.</p>

<p>In my presentation I propose a short investigation on the reasons that underly a lack of scrolling performance, by using the Instruments Core Animation profiling tools provided with Xcode. Scrolling issues are usually caused by transparent, or non-opaque views, like labels, which make the rendering engine do extra work for computing how superimposed views blend together. Another major pain point (often more important than the former) is represented by views with rounded corners, which need more iterations to be rendered. In this case, a very simple solution is to use image masks: a semi transparent image to be superimposed to the view that needs rounded corners. If the view is an ImageView, the <a href="http://developer.appcelerator.com/apidoc/mobile/latest/Titanium.UI.MaskedImage-object"><code>Ti.UI.MaskedImage</code></a> component does just the right job.</p>

<p>There&#8217;s an interesting session from Apple&#8217;s WWDC 2010 where these kinds of performance issues are analyzed. The talk is titled &#8220;Performance Optimization on iPhone OS&#8221;. If you are registered as an Apple developer you can download the video from <a href="https://developer.apple.com/videos/wwdc/2010/">https://developer.apple.com/videos/wwdc/2010/</a>.</p>

<p>So we come to the center point of my reasoning. If we are not able to fulfill our performance goals by tweaking our use of the standard API, Titanium allows us to implement our performance-critical components as native modules. In other words, we can trade flexibility for gaining performance. For doing so, we must give up some amount of generality and the possibility to reuse our code in other applications by implementing an optimized component that exposes an application-specific semantic: both the API and the implementation of the module will be tailored on the peculiar application and it&#8217;s performance requirements.</p>

<p>Following the table view example, on iOS this translates into having tableview rows with a hardcoded layout, possibly with sub-views whose <code>opaque</code> property is set to true on iOS, and so on. Would we still be dissatisfied with the result, we can always rely on the concept of fast-cells, which  are tableview cells actually composed by a single view, where all information to be shown is laid out by using low level CoreGraphics drawing primitives. Check out the <a href="http://iosboilerplate.com/">iOS Boilerplate project</a> and <a href="http://developer.apple.com/library/ios/#samplecode/TableViewSuite/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007318">this coding example from Apple</a> for additional information.</p>

<p>Summarizing, what does all this mean? That Titanium Mobile is a tool allowing us to create very complex <strong>cross platform</strong> mobile applications in a fraction of the time needed to make parallel developments using native SDKs. The possibility to extend the framework with native modules opens up a wide range of development scenarios, enabling both the reuse of existing native libraries, and the optimization of performance-critical portions of the app, when needed.</p>

<p>Is it a panacea? Not really, IMHO. I use Titanium since version 0.8, and despite a visible effort in making it better release after release, even now that version 2.0 is out I think it&#8217;s still a bit immature. I still see it somewhat a platform made for hackers, rather than for developers, as without a deep knowledge of its internals it&#8217;s often impractical to overcome even trivial issues like a failed build. A quick look at most of the questions on the Q&amp;A forum will suffice to support my point of view on this.</p>

<p>That said, even taking into account the problems, I think Titanium is the right tool every time we are dealing with an application that needs to support both iOS and Android platforms, whose value resides in a rather complex business logic, instead of just in the presentation layer. In these cases, we don&#8217;t want to develop, test, debug, and maintain different implementations of the same solution across different platforms. Moreover, being based on a high level abstraction layer (JS language + very flexible API), Titanium allows very quick iterations in the solution space, which is an invaluable feature when we are trying to validate business ideas against unkown markets.</p>

<p>Finally, here you find the slides of my presentation:</p>

<div style="width:425px" id="__ss_13102557"><strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/omorandi/titanium-mobile-flexibility-vs-performance-13102557" title="Titanium Mobile: flexibility vs. performance">Titanium Mobile: flexibility vs. performance</a></strong><object id="__sse13102557" width="425" height="355"><param name="movie" value="http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=oliviermorandi-whymca12-120528055815-phpapp01&stripped_title=titanium-mobile-flexibility-vs-performance-13102557&userName=omorandi" /><param name="allowFullScreen" value="true"/><param name="allowScriptAccess" value="always"/><param name="wmode" value="transparent"/><embed name="__sse13102557" src="http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=oliviermorandi-whymca12-120528055815-phpapp01&stripped_title=titanium-mobile-flexibility-vs-performance-13102557&userName=omorandi" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="transparent" width="425" height="355"></embed></object><div style="padding:5px 0 12px">View more <a href="http://www.slideshare.net/">presentations</a> from <a href="http://www.slideshare.net/omorandi">omorandi</a>.</div></div>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/post/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
	<center><a href="http://2013.ticonf.eu/?utm_source=FreeBlogAd&utm_medium=Web&utm_campaign=TiConf"><img src="/images/ticonf.eu.2013.jpeg" alt="tiConf 2013" /></a></center>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/debugging-titanium-apps-with-chrome-devtools/">Debugging Titanium Apps with Chrome DevTools</a>
      </li>
    
      <li class="post">
        <a href="/ticonf-2013-and-new-titanium-modules/">tiConf 2013 and new Titanium modules</a>
      </li>
    
      <li class="post">
        <a href="/introducing-tiprofiler-for-ios/">Introducing TiProfiler for iOS</a>
      </li>
    
      <li class="post">
        <a href="/testing-titanium-mobile-applications-with-jasmine-and-sinon-part-i/">Testing Titanium Mobile applications with Jasmine and Sinon (part I)</a>
      </li>
    
      <li class="post">
        <a href="/titanium-mobile-flexibility-vs-performance/">Titanium Mobile: Flexibility vs. Performance</a>
      </li>
    
  </ul>
</section>
<section>
  <a href="/tcmd"><img src="/images/tcmd_color.png" alt="tcmd-logo" /></a>
</section>
<section>
  <h1>Coderwall</h1>
  <p>
  <script type="text/javascript">
    function display_coderwall(args) {
        var badges = args["data"]["badges"];
        for ( var i = 0; i < badges.length; i++ ) {
            document.write('<img src="'+ badges[i]["badge"] + '" width="80" height="80" />');
        }
    }
  </script>
  <script src="http://coderwall.com/omorandi.json?callback=display_coderwall"></script>
  </p>
  <p style="text-align: right;"><a href="http://coderwall.com/omorandi">Powered by coderwall.com</a></p>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/omorandi">@omorandi</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'omorandi',
            count: 3,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("olivier_morandi", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/olivier_morandi" class="twitter-follow-button" data-show-count="false">Follow @olivier_morandi</a>
  
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - TiNinja -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'tininja';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
